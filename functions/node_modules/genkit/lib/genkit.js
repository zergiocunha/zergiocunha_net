"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var genkit_exports = {};
__export(genkit_exports, {
  Genkit: () => Genkit,
  __disableReflectionApi: () => __disableReflectionApi,
  genkit: () => genkit
});
module.exports = __toCommonJS(genkit_exports);
var import_ai = require("@genkit-ai/ai");
var import_embedder = require("@genkit-ai/ai/embedder");
var import_evaluator = require("@genkit-ai/ai/evaluator");
var import_formats = require("@genkit-ai/ai/formats");
var import_model = require("@genkit-ai/ai/model");
var import_reranker = require("@genkit-ai/ai/reranker");
var import_retriever = require("@genkit-ai/ai/retriever");
var import_session = require("@genkit-ai/ai/session");
var import_tool = require("@genkit-ai/ai/tool");
var import_core = require("@genkit-ai/core");
var import_dotprompt = require("@genkit-ai/dotprompt");
var import_uuid = require("uuid");
var import_logging = require("./logging.js");
var import_plugin = require("./plugin.js");
var import_registry = require("./registry.js");
var import_schema = require("./schema.js");
var import_tool2 = require("./tool.js");
class Genkit {
  constructor(options) {
    /** Environments that have been configured (at minimum dev). */
    this.configuredEnvs = /* @__PURE__ */ new Set(["dev"]);
    /** Reflection server for this registry. May be null if not started. */
    this.reflectionServer = null;
    /** Flow server. May be null if the flow server is not enabled in configuration or not started. */
    this.flowServer = null;
    /** List of flows that have been registered in this instance. */
    this.registeredFlows = [];
    this.options = options || {};
    this.registry = new import_registry.Registry();
    this.configure();
    if ((0, import_core.isDevEnv)() && !disableReflectionApi) {
      this.reflectionServer = new import_core.ReflectionServer(this.registry, {
        configuredEnvs: [...this.configuredEnvs]
      });
      this.reflectionServer.start().catch((e) => import_logging.logger.error);
    }
  }
  /**
   * Defines and registers a non-streaming flow.
   *
   * @todo TODO: Improve this documentation (show snippets, etc).
   */
  defineFlow(config, fn) {
    const flow = (0, import_core.defineFlow)(this.registry, config, fn);
    this.registeredFlows.push(flow.flow);
    return flow;
  }
  /**
   * Defines and registers a streaming flow.
   *
   * @deprecated use {@link defineFlow}
   */
  defineStreamingFlow(config, fn) {
    const flow = (0, import_core.defineStreamingFlow)(
      this.registry,
      typeof config === "string" ? { name: config } : config,
      fn
    );
    this.registeredFlows.push(flow.flow);
    return flow;
  }
  /**
   * Defines and registers a tool.
   *
   * Tools can be passed to models by name or value during `generate` calls to be called automatically based on the prompt and situation.
   */
  defineTool(config, fn) {
    return (0, import_ai.defineTool)(this.registry, config, fn);
  }
  /**
   * Defines and registers a schema from a Zod schema.
   *
   * Defined schemas can be referenced by `name` in prompts in place of inline schemas.
   */
  defineSchema(name, schema) {
    return (0, import_core.defineSchema)(this.registry, name, schema);
  }
  /**
   * Defines and registers a custom model output formatter.
   *
   * Here's an example of a custom JSON output formatter:
   *
   * ```ts
   * import { extractJson } from 'genkit/extract';
   *
   * ai.defineFormat(
   *   { name: 'customJson' },
   *   (schema) => {
   *     let instructions: string | undefined;
   *     if (schema) {
   *       instructions = `Output should be in JSON format and conform to the following schema:
   * \`\`\`
   * ${JSON.stringify(schema)}
   * \`\`\`
   * `;
   *     }
   *     return {
   *       parseChunk: (chunk) => extractJson(chunk.accumulatedText),
   *       parseMessage: (message) => extractJson(message.text),
   *       instructions,
   *     };
   *   }
   * );
   *
   * const { output } = await ai.generate({
   *   prompt: 'Invent a menu item for a pirate themed restaurant.',
   *   output: { format: 'customJson', schema: MenuItemSchema },
   * });
   * ```
   */
  defineFormat(options, handler) {
    return (0, import_formats.defineFormat)(this.registry, options, handler);
  }
  /**
   * Defines and registers a schema from a JSON schema.
   *
   * Defined schemas can be referenced by `name` in prompts in place of inline schemas.
   */
  defineJsonSchema(name, jsonSchema) {
    return (0, import_core.defineJsonSchema)(this.registry, name, jsonSchema);
  }
  /**
   * Defines a new model and adds it to the registry.
   */
  defineModel(options, runner) {
    return (0, import_model.defineModel)(this.registry, options, runner);
  }
  /**
   * Looks up a prompt by `name` and optional `variant`.
   *
   * @todo TODO: Show an example of a name and variant.
   */
  prompt(name, options) {
    const actionPromise = (() => __async(this, null, function* () {
      var _a;
      let action = yield this.registry.lookupAction(
        `/prompt/${name}${(options == null ? void 0 : options.variant) ? `.${options == null ? void 0 : options.variant}` : ""}`
      );
      if (!action) {
        action = (yield (0, import_dotprompt.prompt)(this.registry, name, __spreadProps(__spreadValues({}, options), {
          dir: (_a = this.options.promptDir) != null ? _a : "./prompts"
        }))).promptAction;
      }
      const _b = action.__action.metadata.prompt, { template } = _b, opts = __objRest(_b, ["template"]);
      return { action, opts };
    }))();
    return this.wrapPromptActionInExecutablePrompt(
      actionPromise.then(({ action }) => action),
      actionPromise.then(({ opts }) => opts)
    );
  }
  definePrompt(options, templateOrFn) {
    var _a, _b;
    if (!options.name) {
      throw new Error("options.name is required");
    }
    if (!options.name) {
      throw new Error("options.name is required");
    }
    if (typeof templateOrFn === "string") {
      const dotprompt = (0, import_dotprompt.defineDotprompt)(
        this.registry,
        __spreadProps(__spreadValues({}, options), {
          tools: options.tools
        }),
        templateOrFn
      );
      return this.wrapPromptActionInExecutablePrompt(
        dotprompt.promptAction,
        options,
        dotprompt
      );
    } else {
      const p = (0, import_ai.definePrompt)(
        this.registry,
        {
          name: options.name,
          inputJsonSchema: (_a = options.input) == null ? void 0 : _a.jsonSchema,
          inputSchema: (_b = options.input) == null ? void 0 : _b.schema,
          description: options.description
        },
        (input) => __async(this, null, function* () {
          const response = yield templateOrFn(input);
          if (!response.tools && options.tools) {
            response.tools = (yield (0, import_tool.resolveTools)(this.registry, options.tools)).map((t) => (0, import_tool2.toToolDefinition)(t));
          }
          if (!response.output && options.output) {
            response.output = {
              schema: (0, import_schema.toJsonSchema)({
                schema: options.output.schema,
                jsonSchema: options.output.jsonSchema
              })
            };
          }
          return response;
        })
      );
      return this.wrapPromptActionInExecutablePrompt(p, options);
    }
  }
  wrapPromptActionInExecutablePrompt(promptAction, options, dotprompt) {
    const executablePrompt = (input, opts) => __async(this, null, function* () {
      const renderedOpts = yield executablePrompt.render(__spreadProps(__spreadValues({}, opts), {
        input
      }));
      return this.generate(renderedOpts);
    });
    executablePrompt.stream = (input, opts) => __async(this, null, function* () {
      const renderedOpts = yield executablePrompt.render(__spreadProps(__spreadValues({}, opts), {
        input
      }));
      return this.generateStream(renderedOpts);
    });
    executablePrompt.render = (opt) => __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      let model;
      options = yield options;
      const modelArg = (_a = opt == null ? void 0 : opt.model) != null ? _a : options.model;
      if (modelArg) {
        model = yield this.resolveModel(modelArg);
        if (!model) {
          throw new Error(`Model ${modelArg} not found`);
        }
      }
      const p = yield promptAction;
      const promptResult = yield dotprompt ? dotprompt.render(opt) : p(opt.input);
      const resultOptions = {
        messages: promptResult.messages,
        docs: promptResult.docs,
        tools: (_b = promptResult.tools) != null ? _b : options.tools,
        output: ((_c = promptResult.output) == null ? void 0 : _c.format) || ((_d = promptResult.output) == null ? void 0 : _d.schema) ? {
          format: (_e = promptResult.output) == null ? void 0 : _e.format,
          jsonSchema: dotprompt ? (_f = promptResult.output) == null ? void 0 : _f.jsonSchema : promptResult.output.schema,
          contentType: (_g = promptResult.output) == null ? void 0 : _g.contentType,
          instructions: (_h = promptResult.output) == null ? void 0 : _h.instructions,
          schema: (_i = promptResult.output) == null ? void 0 : _i.schema
        } : options.output,
        config: __spreadValues(__spreadValues(__spreadValues({}, options.config), promptResult.config), opt.config),
        model
      };
      delete resultOptions.input;
      if (promptResult.prompt) {
        resultOptions.prompt = promptResult.prompt;
      }
      return resultOptions;
    });
    executablePrompt.asTool = () => __async(this, null, function* () {
      return yield promptAction;
    });
    return executablePrompt;
  }
  /**
   * Creates a retriever action for the provided {@link RetrieverFn} implementation.
   */
  defineRetriever(options, runner) {
    return (0, import_retriever.defineRetriever)(this.registry, options, runner);
  }
  /**
   * defineSimpleRetriever makes it easy to map existing data into documents that
   * can be used for prompt augmentation.
   *
   * @param options Configuration options for the retriever.
   * @param handler A function that queries a datastore and returns items from which to extract documents.
   * @returns A Genkit retriever.
   */
  defineSimpleRetriever(options, handler) {
    return (0, import_retriever.defineSimpleRetriever)(this.registry, options, handler);
  }
  /**
   * Creates an indexer action for the provided {@link IndexerFn} implementation.
   */
  defineIndexer(options, runner) {
    return (0, import_retriever.defineIndexer)(this.registry, options, runner);
  }
  /**
   * Creates evaluator action for the provided {@link EvaluatorFn} implementation.
   */
  defineEvaluator(options, runner) {
    return (0, import_evaluator.defineEvaluator)(this.registry, options, runner);
  }
  /**
   * Creates embedder model for the provided {@link EmbedderFn} model implementation.
   */
  defineEmbedder(options, runner) {
    return (0, import_embedder.defineEmbedder)(this.registry, options, runner);
  }
  /**
   * create a handlebards helper (https://handlebarsjs.com/guide/block-helpers.html) to be used in dotpormpt templates.
   */
  defineHelper(name, fn) {
    return (0, import_dotprompt.defineHelper)(name, fn);
  }
  /**
   * Creates a handlebars partial (https://handlebarsjs.com/guide/partials.html) to be used in dotpormpt templates.
   */
  definePartial(name, source) {
    return (0, import_dotprompt.definePartial)(name, source);
  }
  /**
   *  Creates a reranker action for the provided {@link RerankerFn} implementation.
   */
  defineReranker(options, runner) {
    return (0, import_reranker.defineReranker)(this.registry, options, runner);
  }
  /**
   * Embeds the given `content` using the specified `embedder`.
   */
  embed(params) {
    return (0, import_ai.embed)(this.registry, params);
  }
  /**
   * A veneer for interacting with embedder models in bulk.
   */
  embedMany(params) {
    return (0, import_embedder.embedMany)(this.registry, params);
  }
  /**
   * Evaluates the given `dataset` using the specified `evaluator`.
   */
  evaluate(params) {
    return (0, import_ai.evaluate)(this.registry, params);
  }
  /**
   * Reranks documents from a {@link RerankerArgument} based on the provided query.
   */
  rerank(params) {
    return (0, import_ai.rerank)(this.registry, params);
  }
  /**
   * Indexes `documents` using the provided `indexer`.
   */
  index(params) {
    return (0, import_retriever.index)(this.registry, params);
  }
  /**
   * Retrieves documents from the `retriever` based on the provided `query`.
   */
  retrieve(params) {
    return (0, import_ai.retrieve)(this.registry, params);
  }
  generate(options) {
    return __async(this, null, function* () {
      let resolvedOptions;
      if (options instanceof Promise) {
        resolvedOptions = yield options;
      } else if (typeof options === "string" || Array.isArray(options)) {
        resolvedOptions = {
          prompt: options
        };
      } else {
        resolvedOptions = options;
      }
      return (0, import_ai.generate)(this.registry, resolvedOptions);
    });
  }
  generateStream(options) {
    return __async(this, null, function* () {
      let resolvedOptions;
      if (options instanceof Promise) {
        resolvedOptions = yield options;
      } else if (typeof options === "string" || Array.isArray(options)) {
        resolvedOptions = {
          prompt: options
        };
      } else {
        resolvedOptions = options;
      }
      return (0, import_ai.generateStream)(this.registry, resolvedOptions);
    });
  }
  /**
   * Create a chat session with the provided options.
   *
   * ```ts
   * const chat = ai.chat({
   *   system: 'talk like a pirate',
   * })
   * let response = await chat.send('tell me a joke')
   * response = await chat.send('another one')
   * ```
   */
  chat(preambleOrOptions, maybeOptions) {
    let options;
    let preamble;
    if (maybeOptions) {
      options = maybeOptions;
    }
    if (preambleOrOptions) {
      if ((0, import_ai.isExecutablePrompt)(preambleOrOptions)) {
        preamble = preambleOrOptions;
      } else {
        options = preambleOrOptions;
      }
    }
    const session = this.createSession();
    if (preamble) {
      return session.chat(preamble, options);
    }
    return session.chat(options);
  }
  /**
   * Create a session for this environment.
   */
  createSession(options) {
    const sessionId = (0, import_uuid.v4)();
    const sessionData = {
      id: sessionId,
      state: options == null ? void 0 : options.initialState
    };
    return new import_session.Session(this.registry, {
      id: sessionId,
      sessionData,
      store: options == null ? void 0 : options.store
    });
  }
  /**
   * Loads a session from the store.
   */
  loadSession(sessionId, options) {
    return __async(this, null, function* () {
      if (!options.store) {
        throw new Error("options.store is required");
      }
      const sessionData = yield options.store.get(sessionId);
      return new import_session.Session(this.registry, {
        id: sessionId,
        sessionData,
        store: options.store
      });
    });
  }
  /**
   * Gets the current session from async local storage.
   */
  currentSession() {
    const currentSession = (0, import_session.getCurrentSession)();
    if (!currentSession) {
      throw new import_session.SessionError("not running within a session");
    }
    return currentSession;
  }
  /**
   * Configures the Genkit instance.
   */
  configure() {
    var _a;
    const activeRegistry = this.registry;
    (0, import_formats.configureFormats)(activeRegistry);
    const plugins = [...(_a = this.options.plugins) != null ? _a : []];
    if (this.options.model) {
      this.registry.registerValue(
        "defaultModel",
        "defaultModel",
        this.options.model
      );
    }
    if (this.options.promptDir !== null) {
      const dotprompt = (0, import_plugin.genkitPlugin)("dotprompt", (ai) => __async(this, null, function* () {
        var _a2;
        (0, import_dotprompt.loadPromptFolder)(
          this.registry,
          (_a2 = this.options.promptDir) != null ? _a2 : "./prompts",
          ""
        );
      }));
      plugins.push(dotprompt);
    }
    plugins.forEach((plugin) => {
      const loadedPlugin = plugin(this);
      import_logging.logger.debug(`Registering plugin ${loadedPlugin.name}...`);
      activeRegistry.registerPluginProvider(loadedPlugin.name, {
        name: loadedPlugin.name,
        initializer() {
          return __async(this, null, function* () {
            import_logging.logger.debug(`Initializing plugin ${loadedPlugin.name}:`);
            yield loadedPlugin.initializer();
          });
        }
      });
    });
  }
  /**
   * Stops all servers.
   */
  stopServers() {
    return __async(this, null, function* () {
      var _a, _b;
      yield Promise.all([(_a = this.reflectionServer) == null ? void 0 : _a.stop(), (_b = this.flowServer) == null ? void 0 : _b.stop()]);
      this.reflectionServer = null;
      this.flowServer = null;
    });
  }
  resolveModel(modelArg) {
    return __async(this, null, function* () {
      if (!modelArg) {
        if (!this.options.model) {
          throw new Error("Unable to resolve model.");
        }
        return this.resolveModel(this.options.model);
      }
      if (typeof modelArg === "string") {
        return yield this.registry.lookupAction(
          `/model/${modelArg}`
        );
      } else if (modelArg.__action) {
        return modelArg;
      } else {
        const ref = modelArg;
        return yield this.registry.lookupAction(
          `/model/${ref.name}`
        );
      }
    });
  }
  startFlowServer(options) {
    const flowServer = new import_core.FlowServer(this.registry, options);
    flowServer.start();
    return flowServer;
  }
}
function genkit(options) {
  return new Genkit(options);
}
const shutdown = () => __async(void 0, null, function* () {
  import_logging.logger.info("Shutting down all Genkit servers...");
  yield Promise.all([import_core.ReflectionServer.stopAll(), import_core.FlowServer.stopAll()]);
  process.exit(0);
});
process.on("SIGTERM", shutdown);
process.on("SIGINT", shutdown);
let disableReflectionApi = false;
function __disableReflectionApi() {
  disableReflectionApi = true;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Genkit,
  __disableReflectionApi,
  genkit
});
//# sourceMappingURL=genkit.js.map