import {
  __async,
  __objRest,
  __spreadProps,
  __spreadValues
} from "./chunk-7LUMLJGI.mjs";
import {
  definePrompt,
  defineTool,
  embed,
  evaluate,
  generate,
  generateStream,
  isExecutablePrompt,
  rerank,
  retrieve
} from "@genkit-ai/ai";
import {
  defineEmbedder,
  embedMany
} from "@genkit-ai/ai/embedder";
import {
  defineEvaluator
} from "@genkit-ai/ai/evaluator";
import {
  configureFormats,
  defineFormat
} from "@genkit-ai/ai/formats";
import {
  defineModel
} from "@genkit-ai/ai/model";
import {
  defineReranker
} from "@genkit-ai/ai/reranker";
import {
  defineIndexer,
  defineRetriever,
  defineSimpleRetriever,
  index
} from "@genkit-ai/ai/retriever";
import {
  getCurrentSession,
  Session,
  SessionError
} from "@genkit-ai/ai/session";
import { resolveTools } from "@genkit-ai/ai/tool";
import {
  defineFlow,
  defineJsonSchema,
  defineSchema,
  defineStreamingFlow,
  FlowServer,
  isDevEnv,
  ReflectionServer
} from "@genkit-ai/core";
import {
  defineDotprompt,
  defineHelper,
  definePartial,
  loadPromptFolder,
  prompt
} from "@genkit-ai/dotprompt";
import { v4 as uuidv4 } from "uuid";
import { logger } from "./logging.js";
import { genkitPlugin } from "./plugin.js";
import { Registry } from "./registry.js";
import { toJsonSchema } from "./schema.js";
import { toToolDefinition } from "./tool.js";
class Genkit {
  constructor(options) {
    /** Environments that have been configured (at minimum dev). */
    this.configuredEnvs = /* @__PURE__ */ new Set(["dev"]);
    /** Reflection server for this registry. May be null if not started. */
    this.reflectionServer = null;
    /** Flow server. May be null if the flow server is not enabled in configuration or not started. */
    this.flowServer = null;
    /** List of flows that have been registered in this instance. */
    this.registeredFlows = [];
    this.options = options || {};
    this.registry = new Registry();
    this.configure();
    if (isDevEnv() && !disableReflectionApi) {
      this.reflectionServer = new ReflectionServer(this.registry, {
        configuredEnvs: [...this.configuredEnvs]
      });
      this.reflectionServer.start().catch((e) => logger.error);
    }
  }
  /**
   * Defines and registers a non-streaming flow.
   *
   * @todo TODO: Improve this documentation (show snippets, etc).
   */
  defineFlow(config, fn) {
    const flow = defineFlow(this.registry, config, fn);
    this.registeredFlows.push(flow.flow);
    return flow;
  }
  /**
   * Defines and registers a streaming flow.
   *
   * @deprecated use {@link defineFlow}
   */
  defineStreamingFlow(config, fn) {
    const flow = defineStreamingFlow(
      this.registry,
      typeof config === "string" ? { name: config } : config,
      fn
    );
    this.registeredFlows.push(flow.flow);
    return flow;
  }
  /**
   * Defines and registers a tool.
   *
   * Tools can be passed to models by name or value during `generate` calls to be called automatically based on the prompt and situation.
   */
  defineTool(config, fn) {
    return defineTool(this.registry, config, fn);
  }
  /**
   * Defines and registers a schema from a Zod schema.
   *
   * Defined schemas can be referenced by `name` in prompts in place of inline schemas.
   */
  defineSchema(name, schema) {
    return defineSchema(this.registry, name, schema);
  }
  /**
   * Defines and registers a custom model output formatter.
   *
   * Here's an example of a custom JSON output formatter:
   *
   * ```ts
   * import { extractJson } from 'genkit/extract';
   *
   * ai.defineFormat(
   *   { name: 'customJson' },
   *   (schema) => {
   *     let instructions: string | undefined;
   *     if (schema) {
   *       instructions = `Output should be in JSON format and conform to the following schema:
   * \`\`\`
   * ${JSON.stringify(schema)}
   * \`\`\`
   * `;
   *     }
   *     return {
   *       parseChunk: (chunk) => extractJson(chunk.accumulatedText),
   *       parseMessage: (message) => extractJson(message.text),
   *       instructions,
   *     };
   *   }
   * );
   *
   * const { output } = await ai.generate({
   *   prompt: 'Invent a menu item for a pirate themed restaurant.',
   *   output: { format: 'customJson', schema: MenuItemSchema },
   * });
   * ```
   */
  defineFormat(options, handler) {
    return defineFormat(this.registry, options, handler);
  }
  /**
   * Defines and registers a schema from a JSON schema.
   *
   * Defined schemas can be referenced by `name` in prompts in place of inline schemas.
   */
  defineJsonSchema(name, jsonSchema) {
    return defineJsonSchema(this.registry, name, jsonSchema);
  }
  /**
   * Defines a new model and adds it to the registry.
   */
  defineModel(options, runner) {
    return defineModel(this.registry, options, runner);
  }
  /**
   * Looks up a prompt by `name` and optional `variant`.
   *
   * @todo TODO: Show an example of a name and variant.
   */
  prompt(name, options) {
    const actionPromise = (() => __async(this, null, function* () {
      var _a;
      let action = yield this.registry.lookupAction(
        `/prompt/${name}${(options == null ? void 0 : options.variant) ? `.${options == null ? void 0 : options.variant}` : ""}`
      );
      if (!action) {
        action = (yield prompt(this.registry, name, __spreadProps(__spreadValues({}, options), {
          dir: (_a = this.options.promptDir) != null ? _a : "./prompts"
        }))).promptAction;
      }
      const _b = action.__action.metadata.prompt, { template } = _b, opts = __objRest(_b, ["template"]);
      return { action, opts };
    }))();
    return this.wrapPromptActionInExecutablePrompt(
      actionPromise.then(({ action }) => action),
      actionPromise.then(({ opts }) => opts)
    );
  }
  definePrompt(options, templateOrFn) {
    var _a, _b;
    if (!options.name) {
      throw new Error("options.name is required");
    }
    if (!options.name) {
      throw new Error("options.name is required");
    }
    if (typeof templateOrFn === "string") {
      const dotprompt = defineDotprompt(
        this.registry,
        __spreadProps(__spreadValues({}, options), {
          tools: options.tools
        }),
        templateOrFn
      );
      return this.wrapPromptActionInExecutablePrompt(
        dotprompt.promptAction,
        options,
        dotprompt
      );
    } else {
      const p = definePrompt(
        this.registry,
        {
          name: options.name,
          inputJsonSchema: (_a = options.input) == null ? void 0 : _a.jsonSchema,
          inputSchema: (_b = options.input) == null ? void 0 : _b.schema,
          description: options.description
        },
        (input) => __async(this, null, function* () {
          const response = yield templateOrFn(input);
          if (!response.tools && options.tools) {
            response.tools = (yield resolveTools(this.registry, options.tools)).map((t) => toToolDefinition(t));
          }
          if (!response.output && options.output) {
            response.output = {
              schema: toJsonSchema({
                schema: options.output.schema,
                jsonSchema: options.output.jsonSchema
              })
            };
          }
          return response;
        })
      );
      return this.wrapPromptActionInExecutablePrompt(p, options);
    }
  }
  wrapPromptActionInExecutablePrompt(promptAction, options, dotprompt) {
    const executablePrompt = (input, opts) => __async(this, null, function* () {
      const renderedOpts = yield executablePrompt.render(__spreadProps(__spreadValues({}, opts), {
        input
      }));
      return this.generate(renderedOpts);
    });
    executablePrompt.stream = (input, opts) => __async(this, null, function* () {
      const renderedOpts = yield executablePrompt.render(__spreadProps(__spreadValues({}, opts), {
        input
      }));
      return this.generateStream(renderedOpts);
    });
    executablePrompt.render = (opt) => __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      let model;
      options = yield options;
      const modelArg = (_a = opt == null ? void 0 : opt.model) != null ? _a : options.model;
      if (modelArg) {
        model = yield this.resolveModel(modelArg);
        if (!model) {
          throw new Error(`Model ${modelArg} not found`);
        }
      }
      const p = yield promptAction;
      const promptResult = yield dotprompt ? dotprompt.render(opt) : p(opt.input);
      const resultOptions = {
        messages: promptResult.messages,
        docs: promptResult.docs,
        tools: (_b = promptResult.tools) != null ? _b : options.tools,
        output: ((_c = promptResult.output) == null ? void 0 : _c.format) || ((_d = promptResult.output) == null ? void 0 : _d.schema) ? {
          format: (_e = promptResult.output) == null ? void 0 : _e.format,
          jsonSchema: dotprompt ? (_f = promptResult.output) == null ? void 0 : _f.jsonSchema : promptResult.output.schema,
          contentType: (_g = promptResult.output) == null ? void 0 : _g.contentType,
          instructions: (_h = promptResult.output) == null ? void 0 : _h.instructions,
          schema: (_i = promptResult.output) == null ? void 0 : _i.schema
        } : options.output,
        config: __spreadValues(__spreadValues(__spreadValues({}, options.config), promptResult.config), opt.config),
        model
      };
      delete resultOptions.input;
      if (promptResult.prompt) {
        resultOptions.prompt = promptResult.prompt;
      }
      return resultOptions;
    });
    executablePrompt.asTool = () => __async(this, null, function* () {
      return yield promptAction;
    });
    return executablePrompt;
  }
  /**
   * Creates a retriever action for the provided {@link RetrieverFn} implementation.
   */
  defineRetriever(options, runner) {
    return defineRetriever(this.registry, options, runner);
  }
  /**
   * defineSimpleRetriever makes it easy to map existing data into documents that
   * can be used for prompt augmentation.
   *
   * @param options Configuration options for the retriever.
   * @param handler A function that queries a datastore and returns items from which to extract documents.
   * @returns A Genkit retriever.
   */
  defineSimpleRetriever(options, handler) {
    return defineSimpleRetriever(this.registry, options, handler);
  }
  /**
   * Creates an indexer action for the provided {@link IndexerFn} implementation.
   */
  defineIndexer(options, runner) {
    return defineIndexer(this.registry, options, runner);
  }
  /**
   * Creates evaluator action for the provided {@link EvaluatorFn} implementation.
   */
  defineEvaluator(options, runner) {
    return defineEvaluator(this.registry, options, runner);
  }
  /**
   * Creates embedder model for the provided {@link EmbedderFn} model implementation.
   */
  defineEmbedder(options, runner) {
    return defineEmbedder(this.registry, options, runner);
  }
  /**
   * create a handlebards helper (https://handlebarsjs.com/guide/block-helpers.html) to be used in dotpormpt templates.
   */
  defineHelper(name, fn) {
    return defineHelper(name, fn);
  }
  /**
   * Creates a handlebars partial (https://handlebarsjs.com/guide/partials.html) to be used in dotpormpt templates.
   */
  definePartial(name, source) {
    return definePartial(name, source);
  }
  /**
   *  Creates a reranker action for the provided {@link RerankerFn} implementation.
   */
  defineReranker(options, runner) {
    return defineReranker(this.registry, options, runner);
  }
  /**
   * Embeds the given `content` using the specified `embedder`.
   */
  embed(params) {
    return embed(this.registry, params);
  }
  /**
   * A veneer for interacting with embedder models in bulk.
   */
  embedMany(params) {
    return embedMany(this.registry, params);
  }
  /**
   * Evaluates the given `dataset` using the specified `evaluator`.
   */
  evaluate(params) {
    return evaluate(this.registry, params);
  }
  /**
   * Reranks documents from a {@link RerankerArgument} based on the provided query.
   */
  rerank(params) {
    return rerank(this.registry, params);
  }
  /**
   * Indexes `documents` using the provided `indexer`.
   */
  index(params) {
    return index(this.registry, params);
  }
  /**
   * Retrieves documents from the `retriever` based on the provided `query`.
   */
  retrieve(params) {
    return retrieve(this.registry, params);
  }
  generate(options) {
    return __async(this, null, function* () {
      let resolvedOptions;
      if (options instanceof Promise) {
        resolvedOptions = yield options;
      } else if (typeof options === "string" || Array.isArray(options)) {
        resolvedOptions = {
          prompt: options
        };
      } else {
        resolvedOptions = options;
      }
      return generate(this.registry, resolvedOptions);
    });
  }
  generateStream(options) {
    return __async(this, null, function* () {
      let resolvedOptions;
      if (options instanceof Promise) {
        resolvedOptions = yield options;
      } else if (typeof options === "string" || Array.isArray(options)) {
        resolvedOptions = {
          prompt: options
        };
      } else {
        resolvedOptions = options;
      }
      return generateStream(this.registry, resolvedOptions);
    });
  }
  /**
   * Create a chat session with the provided options.
   *
   * ```ts
   * const chat = ai.chat({
   *   system: 'talk like a pirate',
   * })
   * let response = await chat.send('tell me a joke')
   * response = await chat.send('another one')
   * ```
   */
  chat(preambleOrOptions, maybeOptions) {
    let options;
    let preamble;
    if (maybeOptions) {
      options = maybeOptions;
    }
    if (preambleOrOptions) {
      if (isExecutablePrompt(preambleOrOptions)) {
        preamble = preambleOrOptions;
      } else {
        options = preambleOrOptions;
      }
    }
    const session = this.createSession();
    if (preamble) {
      return session.chat(preamble, options);
    }
    return session.chat(options);
  }
  /**
   * Create a session for this environment.
   */
  createSession(options) {
    const sessionId = uuidv4();
    const sessionData = {
      id: sessionId,
      state: options == null ? void 0 : options.initialState
    };
    return new Session(this.registry, {
      id: sessionId,
      sessionData,
      store: options == null ? void 0 : options.store
    });
  }
  /**
   * Loads a session from the store.
   */
  loadSession(sessionId, options) {
    return __async(this, null, function* () {
      if (!options.store) {
        throw new Error("options.store is required");
      }
      const sessionData = yield options.store.get(sessionId);
      return new Session(this.registry, {
        id: sessionId,
        sessionData,
        store: options.store
      });
    });
  }
  /**
   * Gets the current session from async local storage.
   */
  currentSession() {
    const currentSession = getCurrentSession();
    if (!currentSession) {
      throw new SessionError("not running within a session");
    }
    return currentSession;
  }
  /**
   * Configures the Genkit instance.
   */
  configure() {
    var _a;
    const activeRegistry = this.registry;
    configureFormats(activeRegistry);
    const plugins = [...(_a = this.options.plugins) != null ? _a : []];
    if (this.options.model) {
      this.registry.registerValue(
        "defaultModel",
        "defaultModel",
        this.options.model
      );
    }
    if (this.options.promptDir !== null) {
      const dotprompt = genkitPlugin("dotprompt", (ai) => __async(this, null, function* () {
        var _a2;
        loadPromptFolder(
          this.registry,
          (_a2 = this.options.promptDir) != null ? _a2 : "./prompts",
          ""
        );
      }));
      plugins.push(dotprompt);
    }
    plugins.forEach((plugin) => {
      const loadedPlugin = plugin(this);
      logger.debug(`Registering plugin ${loadedPlugin.name}...`);
      activeRegistry.registerPluginProvider(loadedPlugin.name, {
        name: loadedPlugin.name,
        initializer() {
          return __async(this, null, function* () {
            logger.debug(`Initializing plugin ${loadedPlugin.name}:`);
            yield loadedPlugin.initializer();
          });
        }
      });
    });
  }
  /**
   * Stops all servers.
   */
  stopServers() {
    return __async(this, null, function* () {
      var _a, _b;
      yield Promise.all([(_a = this.reflectionServer) == null ? void 0 : _a.stop(), (_b = this.flowServer) == null ? void 0 : _b.stop()]);
      this.reflectionServer = null;
      this.flowServer = null;
    });
  }
  resolveModel(modelArg) {
    return __async(this, null, function* () {
      if (!modelArg) {
        if (!this.options.model) {
          throw new Error("Unable to resolve model.");
        }
        return this.resolveModel(this.options.model);
      }
      if (typeof modelArg === "string") {
        return yield this.registry.lookupAction(
          `/model/${modelArg}`
        );
      } else if (modelArg.__action) {
        return modelArg;
      } else {
        const ref = modelArg;
        return yield this.registry.lookupAction(
          `/model/${ref.name}`
        );
      }
    });
  }
  startFlowServer(options) {
    const flowServer = new FlowServer(this.registry, options);
    flowServer.start();
    return flowServer;
  }
}
function genkit(options) {
  return new Genkit(options);
}
const shutdown = () => __async(void 0, null, function* () {
  logger.info("Shutting down all Genkit servers...");
  yield Promise.all([ReflectionServer.stopAll(), FlowServer.stopAll()]);
  process.exit(0);
});
process.on("SIGTERM", shutdown);
process.on("SIGINT", shutdown);
let disableReflectionApi = false;
function __disableReflectionApi() {
  disableReflectionApi = true;
}
export {
  Genkit,
  __disableReflectionApi,
  genkit
};
//# sourceMappingURL=genkit.mjs.map