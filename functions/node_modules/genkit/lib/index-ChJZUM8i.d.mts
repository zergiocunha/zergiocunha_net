import { ModelArgument, ToolConfig, ToolAction, GenerateRequest, GenerateResponseData, ExecutablePrompt, PromptFn, RetrieverInfo, RetrieverAction, Document, EmbedderInfo, BaseDataPointSchema, EmbedderParams, Embedding, EvaluatorParams, EvalResponses, RerankerParams, RankedDocument, IndexerParams, RetrieverParams, GenerateResponse, Part, GenerationCommonConfigSchema, GenerateOptions, GenerateStreamResponse } from '@genkit-ai/ai';
import { SessionOptions, Session } from '@genkit-ai/ai/session';
import { z, StreamingFlowConfig, FlowFn, CallableFlow, StreamableFlow, JSONSchema, StreamingCallback, FlowServerOptions, FlowServer } from '@genkit-ai/core';
import { PromptMetadata as PromptMetadata$1 } from '@genkit-ai/dotprompt';
import * as _genkit_ai_ai_reranker from '@genkit-ai/ai/reranker';
import { RerankerInfo, RerankerFn } from '@genkit-ai/ai/reranker';
import { ChatOptions, Chat } from '@genkit-ai/ai/chat';
import { EmbedderFn, EmbedderAction, EmbedderArgument, EmbeddingBatch } from '@genkit-ai/ai/embedder';
import { BaseEvalDataPointSchema, EvaluatorFn, EvaluatorAction } from '@genkit-ai/ai/evaluator';
import { Formatter } from '@genkit-ai/ai/formats';
import { DefineModelOptions, GenerateResponseChunkData, ModelAction } from '@genkit-ai/ai/model';
import { RetrieverFn, SimpleRetrieverOptions, IndexerFn, IndexerAction, DocumentData } from '@genkit-ai/ai/retriever';
import { Registry } from '@genkit-ai/core/registry';

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

interface PluginProvider {
    name: string;
    initializer: () => void | Promise<void>;
}
type PluginInit = (genkit: Genkit) => void | Promise<void>;
type GenkitPlugin = (genkit: Genkit) => PluginProvider;
/**
 * Defines a Genkit plugin.
 */
declare function genkitPlugin<T extends PluginInit>(pluginName: string, initFn: T): GenkitPlugin;

/**
 * Options for initializing Genkit.
 */
interface GenkitOptions {
    /** List of plugins to load. */
    plugins?: GenkitPlugin[];
    /** Directory where dotprompts are stored. */
    promptDir?: string;
    /** Default model to use if no model is specified. */
    model?: ModelArgument<any>;
}
/**
 * Metadata for a prompt.
 */
type PromptMetadata<Input extends z.ZodTypeAny = z.ZodTypeAny, Options extends z.ZodTypeAny = z.ZodTypeAny> = Omit<PromptMetadata$1<Input, Options>, 'name'> & {
    /** The name of the prompt. */
    name: string;
};
/**
 * `Genkit` encapsulates a single Genkit instance including the {@link Registry}, {@link ReflectionServer}, {@link FlowServer}, and configuration.
 *
 * Registry keeps track of actions, flows, tools, and many other components. Reflection server exposes an API to inspect the registry and trigger executions of actions in the registry. Flow server exposes flows as HTTP endpoints for production use.
 *
 * There may be multiple Genkit instances in a single codebase.
 */
declare class Genkit {
    /** Developer-configured options. */
    readonly options: GenkitOptions;
    /** Environments that have been configured (at minimum dev). */
    readonly configuredEnvs: Set<string>;
    /** Registry instance that is exclusively modified by this Genkit instance. */
    readonly registry: Registry;
    /** Reflection server for this registry. May be null if not started. */
    private reflectionServer;
    /** Flow server. May be null if the flow server is not enabled in configuration or not started. */
    private flowServer;
    /** List of flows that have been registered in this instance. */
    private registeredFlows;
    constructor(options?: GenkitOptions);
    /**
     * Defines and registers a non-streaming flow.
     *
     * @todo TODO: Improve this documentation (show snippets, etc).
     */
    defineFlow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(config: StreamingFlowConfig<I, O, S> | string, fn: FlowFn<I, O, S>): CallableFlow<I, O, S>;
    /**
     * Defines and registers a streaming flow.
     *
     * @deprecated use {@link defineFlow}
     */
    defineStreamingFlow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(config: StreamingFlowConfig<I, O, S> | string, fn: FlowFn<I, O, S>): StreamableFlow<I, O, S>;
    /**
     * Defines and registers a tool.
     *
     * Tools can be passed to models by name or value during `generate` calls to be called automatically based on the prompt and situation.
     */
    defineTool<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(config: ToolConfig<I, O>, fn: (input: z.infer<I>) => Promise<z.infer<O>>): ToolAction<I, O>;
    /**
     * Defines and registers a schema from a Zod schema.
     *
     * Defined schemas can be referenced by `name` in prompts in place of inline schemas.
     */
    defineSchema<T extends z.ZodTypeAny>(name: string, schema: T): T;
    /**
     * Defines and registers a custom model output formatter.
     *
     * Here's an example of a custom JSON output formatter:
     *
     * ```ts
     * import { extractJson } from 'genkit/extract';
     *
     * ai.defineFormat(
     *   { name: 'customJson' },
     *   (schema) => {
     *     let instructions: string | undefined;
     *     if (schema) {
     *       instructions = `Output should be in JSON format and conform to the following schema:
     * \`\`\`
     * ${JSON.stringify(schema)}
     * \`\`\`
     * `;
     *     }
     *     return {
     *       parseChunk: (chunk) => extractJson(chunk.accumulatedText),
     *       parseMessage: (message) => extractJson(message.text),
     *       instructions,
     *     };
     *   }
     * );
     *
     * const { output } = await ai.generate({
     *   prompt: 'Invent a menu item for a pirate themed restaurant.',
     *   output: { format: 'customJson', schema: MenuItemSchema },
     * });
     * ```
     */
    defineFormat(options: {
        name: string;
    } & Formatter['config'], handler: Formatter['handler']): {
        config: Formatter['config'];
        handler: Formatter['handler'];
    };
    /**
     * Defines and registers a schema from a JSON schema.
     *
     * Defined schemas can be referenced by `name` in prompts in place of inline schemas.
     */
    defineJsonSchema(name: string, jsonSchema: JSONSchema): any;
    /**
     * Defines a new model and adds it to the registry.
     */
    defineModel<CustomOptionsSchema extends z.ZodTypeAny = z.ZodTypeAny>(options: DefineModelOptions<CustomOptionsSchema>, runner: (request: GenerateRequest<CustomOptionsSchema>, streamingCallback?: StreamingCallback<GenerateResponseChunkData>) => Promise<GenerateResponseData>): ModelAction<CustomOptionsSchema>;
    /**
     * Looks up a prompt by `name` and optional `variant`.
     *
     * @todo TODO: Show an example of a name and variant.
     */
    prompt<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = z.ZodTypeAny>(name: string, options?: {
        variant?: string;
    }): ExecutablePrompt<z.infer<I>, O, CustomOptions>;
    /**
     * Defines and registers a function-based prompt.
     *
     * ```ts
     * const hi = ai.definePrompt(
     *   {
     *     name: 'hi',
     *     input: {
     *       schema: z.object({
     *         name: z.string(),
     *       }),
     *     },
     *     config: {
     *       temperature: 1,
     *     },
     *   },
     *   async (input) => {
     *     return {
     *       messages: [ { role: 'user', content: [{ text: `hi ${input.name}` }] } ],
     *     };
     *   }
     * );
     * const { text } = await hi({ name: 'Genkit' });
     * ```
     */
    definePrompt<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = z.ZodTypeAny>(options: PromptMetadata<I, CustomOptions>, fn: PromptFn<I>): ExecutablePrompt<z.infer<I>, O, CustomOptions>;
    /**
     * Defines and registers a dotprompt.
     *
     * This is an alternative to defining and importing a .prompt file.
     *
     * ```ts
     * const hi = ai.definePrompt(
     *   {
     *     name: 'hi',
     *     input: {
     *       schema: z.object({
     *         name: z.string(),
     *       }),
     *     },
     *   },
     *   'hi {{ name }}'
     * );
     * const { text } = await hi({ name: 'Genkit' });
     * ```
     */
    definePrompt<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = z.ZodTypeAny>(options: PromptMetadata<I, CustomOptions>, template: string): ExecutablePrompt<z.infer<I>, O, CustomOptions>;
    private wrapPromptActionInExecutablePrompt;
    /**
     * Creates a retriever action for the provided {@link RetrieverFn} implementation.
     */
    defineRetriever<OptionsType extends z.ZodTypeAny = z.ZodTypeAny>(options: {
        name: string;
        configSchema?: OptionsType;
        info?: RetrieverInfo;
    }, runner: RetrieverFn<OptionsType>): RetrieverAction<OptionsType>;
    /**
     * defineSimpleRetriever makes it easy to map existing data into documents that
     * can be used for prompt augmentation.
     *
     * @param options Configuration options for the retriever.
     * @param handler A function that queries a datastore and returns items from which to extract documents.
     * @returns A Genkit retriever.
     */
    defineSimpleRetriever<C extends z.ZodTypeAny = z.ZodTypeAny, R = any>(options: SimpleRetrieverOptions<C, R>, handler: (query: Document, config: z.infer<C>) => Promise<R[]>): RetrieverAction<C>;
    /**
     * Creates an indexer action for the provided {@link IndexerFn} implementation.
     */
    defineIndexer<IndexerOptions extends z.ZodTypeAny>(options: {
        name: string;
        embedderInfo?: EmbedderInfo;
        configSchema?: IndexerOptions;
    }, runner: IndexerFn<IndexerOptions>): IndexerAction<IndexerOptions>;
    /**
     * Creates evaluator action for the provided {@link EvaluatorFn} implementation.
     */
    defineEvaluator<DataPoint extends typeof BaseDataPointSchema = typeof BaseDataPointSchema, EvalDataPoint extends typeof BaseEvalDataPointSchema = typeof BaseEvalDataPointSchema, EvaluatorOptions extends z.ZodTypeAny = z.ZodTypeAny>(options: {
        name: string;
        displayName: string;
        definition: string;
        dataPointType?: DataPoint;
        configSchema?: EvaluatorOptions;
        isBilled?: boolean;
    }, runner: EvaluatorFn<EvalDataPoint, EvaluatorOptions>): EvaluatorAction;
    /**
     * Creates embedder model for the provided {@link EmbedderFn} model implementation.
     */
    defineEmbedder<ConfigSchema extends z.ZodTypeAny = z.ZodTypeAny>(options: {
        name: string;
        configSchema?: ConfigSchema;
        info?: EmbedderInfo;
    }, runner: EmbedderFn<ConfigSchema>): EmbedderAction<ConfigSchema>;
    /**
     * create a handlebards helper (https://handlebarsjs.com/guide/block-helpers.html) to be used in dotpormpt templates.
     */
    defineHelper(name: string, fn: Handlebars.HelperDelegate): void;
    /**
     * Creates a handlebars partial (https://handlebarsjs.com/guide/partials.html) to be used in dotpormpt templates.
     */
    definePartial(name: string, source: string): void;
    /**
     *  Creates a reranker action for the provided {@link RerankerFn} implementation.
     */
    defineReranker<OptionsType extends z.ZodTypeAny = z.ZodTypeAny>(options: {
        name: string;
        configSchema?: OptionsType;
        info?: RerankerInfo;
    }, runner: RerankerFn<OptionsType>): _genkit_ai_ai_reranker.RerankerAction<OptionsType>;
    /**
     * Embeds the given `content` using the specified `embedder`.
     */
    embed<CustomOptions extends z.ZodTypeAny>(params: EmbedderParams<CustomOptions>): Promise<Embedding>;
    /**
     * A veneer for interacting with embedder models in bulk.
     */
    embedMany<ConfigSchema extends z.ZodTypeAny = z.ZodTypeAny>(params: {
        embedder: EmbedderArgument<ConfigSchema>;
        content: string[] | DocumentData[];
        metadata?: Record<string, unknown>;
        options?: z.infer<ConfigSchema>;
    }): Promise<EmbeddingBatch>;
    /**
     * Evaluates the given `dataset` using the specified `evaluator`.
     */
    evaluate<DataPoint extends typeof BaseDataPointSchema = typeof BaseDataPointSchema, CustomOptions extends z.ZodTypeAny = z.ZodTypeAny>(params: EvaluatorParams<DataPoint, CustomOptions>): Promise<EvalResponses>;
    /**
     * Reranks documents from a {@link RerankerArgument} based on the provided query.
     */
    rerank<CustomOptions extends z.ZodTypeAny>(params: RerankerParams<CustomOptions>): Promise<Array<RankedDocument>>;
    /**
     * Indexes `documents` using the provided `indexer`.
     */
    index<CustomOptions extends z.ZodTypeAny>(params: IndexerParams<CustomOptions>): Promise<void>;
    /**
     * Retrieves documents from the `retriever` based on the provided `query`.
     */
    retrieve<CustomOptions extends z.ZodTypeAny>(params: RetrieverParams<CustomOptions>): Promise<Array<Document>>;
    /**
     * Make a generate call to the default model with a simple text prompt.
     *
     * ```ts
     * const ai = genkit({
     *   plugins: [googleAI()],
     *   model: gemini15Flash, // default model
     * })
     *
     * const { text } = await ai.generate('hi');
     * ```
     */
    generate<O extends z.ZodTypeAny = z.ZodTypeAny>(strPrompt: string): Promise<GenerateResponse<z.infer<O>>>;
    /**
     * Make a generate call to the default model with a multipart request.
     *
     * ```ts
     * const ai = genkit({
     *   plugins: [googleAI()],
     *   model: gemini15Flash, // default model
     * })
     *
     * const { text } = await ai.generate([
     *   { media: {url: 'http://....'} },
     *   { text: 'describe this image' }
     * ]);
     * ```
     */
    generate<O extends z.ZodTypeAny = z.ZodTypeAny>(parts: Part[]): Promise<GenerateResponse<z.infer<O>>>;
    /**
     * Generate calls a generative model based on the provided prompt and configuration. If
     * `messages` is provided, the generation will include a conversation history in its
     * request. If `tools` are provided, the generate method will automatically resolve
     * tool calls returned from the model unless `returnToolRequests` is set to `true`.
     *
     * See {@link GenerateOptions} for detailed information about available options.
     *
     * ```ts
     * const ai = genkit({
     *   plugins: [googleAI()],
     * })
     *
     * const { text } = await ai.generate({
     *   system: 'talk like a pirate',
     *   prompt: [
     *     { media: { url: 'http://....' } },
     *     { text: 'describe this image' }
     *   ],
     *   messages: conversationHistory,
     *   tools: [ userInfoLookup ],
     *   model: gemini15Flash,
     * });
     * ```
     */
    generate<O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema>(opts: GenerateOptions<O, CustomOptions> | PromiseLike<GenerateOptions<O, CustomOptions>>): Promise<GenerateResponse<z.infer<O>>>;
    /**
     * Make a streaming generate call to the default model with a simple text prompt.
     *
     * ```ts
     * const ai = genkit({
     *   plugins: [googleAI()],
     *   model: gemini15Flash, // default model
     * })
     *
     * const { response, stream } = await ai.generateStream('hi');
     * for await (const chunk of stream) {
     *   console.log(chunk.text);
     * }
     * console.log((await response).text);
     * ```
     */
    generateStream<O extends z.ZodTypeAny = z.ZodTypeAny>(strPrompt: string): Promise<GenerateStreamResponse<z.infer<O>>>;
    /**
     * Make a streaming generate call to the default model with a multipart request.
     *
     * ```ts
     * const ai = genkit({
     *   plugins: [googleAI()],
     *   model: gemini15Flash, // default model
     * })
     *
     * const { response, stream } = await ai.generateStream([
     *   { media: {url: 'http://....'} },
     *   { text: 'describe this image' }
     * ]);
     * for await (const chunk of stream) {
     *   console.log(chunk.text);
     * }
     * console.log((await response).text);
     * ```
     */
    generateStream<O extends z.ZodTypeAny = z.ZodTypeAny>(parts: Part[]): Promise<GenerateStreamResponse<z.infer<O>>>;
    /**
     * Streaming generate calls a generative model based on the provided prompt and configuration. If
     * `messages` is provided, the generation will include a conversation history in its
     * request. If `tools` are provided, the generate method will automatically resolve
     * tool calls returned from the model unless `returnToolRequests` is set to `true`.
     *
     * See {@link GenerateOptions} for detailed information about available options.
     *
     * ```ts
     * const ai = genkit({
     *   plugins: [googleAI()],
     * })
     *
     * const { response, stream } = await ai.generateStream({
     *   system: 'talk like a pirate',
     *   prompt: [
     *     { media: { url: 'http://....' } },
     *     { text: 'describe this image' }
     *   ],
     *   messages: conversationHistory,
     *   tools: [ userInfoLookup ],
     *   model: gemini15Flash,
     * });
     * for await (const chunk of stream) {
     *   console.log(chunk.text);
     * }
     * console.log((await response).text);
     * ```
     */
    generateStream<O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema>(parts: GenerateOptions<O, CustomOptions> | PromiseLike<GenerateOptions<O, CustomOptions>>): Promise<GenerateStreamResponse<z.infer<O>>>;
    /**
     * Create a chat session with the provided options.
     *
     * ```ts
     * const chat = ai.chat({
     *   system: 'talk like a pirate',
     * })
     * let response = await chat.send('tell me a joke')
     * response = await chat.send('another one')
     * ```
     */
    chat<I>(options?: ChatOptions<I>): Chat;
    /**
     * Create a chat session with the provided preabmle.
     *
     * ```ts
     * const triageAgent = ai.definePrompt({
     *   system: 'help the user triage a problem',
     * })
     * const chat = ai.chat(triageAgent)
     * const { text } = await chat.send('my phone feels hot');
     * ```
     */
    chat<I>(preamble: ExecutablePrompt<I>, options?: ChatOptions<I>): Chat;
    /**
     * Create a session for this environment.
     */
    createSession<S = any>(options?: SessionOptions<S>): Session<S>;
    /**
     * Loads a session from the store.
     */
    loadSession(sessionId: string, options: SessionOptions): Promise<Session>;
    /**
     * Gets the current session from async local storage.
     */
    currentSession<S = any>(): Session<S>;
    /**
     * Configures the Genkit instance.
     */
    private configure;
    /**
     * Stops all servers.
     */
    stopServers(): Promise<void>;
    private resolveModel;
    startFlowServer(options: FlowServerOptions): FlowServer;
}
/**
 * Initializes Genkit with a set of options.
 *
 * This will create a new Genkit registry, register the provided plugins, stores, and other configuration. This
 * should be called before any flows are registered.
 */
declare function genkit(options: GenkitOptions): Genkit;
declare function __disableReflectionApi(): void;

export { type GenkitPlugin as G, type PluginProvider as P, __disableReflectionApi as _, type GenkitOptions as a, type PromptMetadata as b, Genkit as c, genkit as d, genkitPlugin as g };
