import { randomUUID } from 'crypto';
import * as inquirer from 'inquirer';
import { findToolsConfig, isEvalField, } from '../plugin';
import { logger } from './logger';
import { stackTraceSpans } from './trace';
const JSON_EMPTY_STRING = '""';
export const EVALUATOR_ACTION_PREFIX = '/evaluator';
export const EVALUATOR_METADATA_KEY_DISPLAY_NAME = 'evaluatorDisplayName';
export const EVALUATOR_METADATA_KEY_DEFINITION = 'evaluatorDefinition';
export const EVALUATOR_METADATA_KEY_IS_BILLED = 'evaluatorIsBilled';
export function evaluatorName(action) {
    return `${EVALUATOR_ACTION_PREFIX}/${action.name}`;
}
export function isEvaluator(key) {
    return key.startsWith(EVALUATOR_ACTION_PREFIX);
}
export async function confirmLlmUse(evaluatorActions) {
    const isBilled = evaluatorActions.some((action) => action.metadata && action.metadata[EVALUATOR_METADATA_KEY_IS_BILLED]);
    if (!isBilled) {
        return true;
    }
    const answers = await inquirer.prompt([
        {
            type: 'confirm',
            name: 'confirm',
            message: 'For each example, the evaluation makes calls to APIs that may result in being charged. Do you wish to proceed?',
            default: false,
        },
    ]);
    return answers.confirm;
}
function getRootSpan(trace) {
    return stackTraceSpans(trace);
}
const DEFAULT_INPUT_EXTRACTOR = (trace) => {
    const rootSpan = getRootSpan(trace);
    return rootSpan?.attributes['genkit:input'] || JSON_EMPTY_STRING;
};
const DEFAULT_OUTPUT_EXTRACTOR = (trace) => {
    const rootSpan = getRootSpan(trace);
    return rootSpan?.attributes['genkit:output'] || JSON_EMPTY_STRING;
};
const DEFAULT_CONTEXT_EXTRACTOR = (trace) => {
    return JSON.stringify(Object.values(trace.spans)
        .filter((s) => s.attributes['genkit:metadata:subtype'] === 'retriever')
        .flatMap((s) => {
        const output = JSON.parse(s.attributes['genkit:output']);
        if (!output) {
            return [];
        }
        return output.documents.flatMap((d) => d.content.map((c) => c.text).filter((text) => !!text));
    }));
};
const DEFAULT_FLOW_EXTRACTORS = {
    input: DEFAULT_INPUT_EXTRACTOR,
    output: DEFAULT_OUTPUT_EXTRACTOR,
    context: DEFAULT_CONTEXT_EXTRACTOR,
};
const DEFAULT_MODEL_EXTRACTORS = {
    input: DEFAULT_INPUT_EXTRACTOR,
    output: DEFAULT_OUTPUT_EXTRACTOR,
    context: () => JSON.stringify([]),
};
function getStepAttribute(trace, stepName, attributeName) {
    const attr = attributeName ?? 'genkit:output';
    const values = Object.values(trace.spans)
        .filter((step) => step.displayName === stepName)
        .flatMap((step) => {
        return JSON.parse(step.attributes[attr]);
    });
    if (values.length === 0) {
        return JSON_EMPTY_STRING;
    }
    if (values.length === 1) {
        return JSON.stringify(values[0]);
    }
    return JSON.stringify(values);
}
function getExtractorFromStepName(stepName) {
    return (trace) => {
        return getStepAttribute(trace, stepName);
    };
}
function getExtractorFromStepSelector(stepSelector) {
    return (trace) => {
        let stepName = undefined;
        let selectedAttribute = 'genkit:output';
        if (Object.hasOwn(stepSelector, 'inputOf')) {
            stepName = stepSelector.inputOf;
            selectedAttribute = 'genkit:input';
        }
        else {
            stepName = stepSelector.outputOf;
            selectedAttribute = 'genkit:output';
        }
        if (!stepName) {
            return JSON_EMPTY_STRING;
        }
        else {
            return getStepAttribute(trace, stepName, selectedAttribute);
        }
    };
}
function getExtractorMap(extractor) {
    let extractorMap = {};
    for (const [key, value] of Object.entries(extractor)) {
        if (isEvalField(key)) {
            if (typeof value === 'string') {
                extractorMap[key] = getExtractorFromStepName(value);
            }
            else if (typeof value === 'object') {
                extractorMap[key] = getExtractorFromStepSelector(value);
            }
            else if (typeof value === 'function') {
                extractorMap[key] = value;
            }
        }
    }
    return extractorMap;
}
export async function getEvalExtractors(actionRef) {
    if (actionRef.startsWith('/model')) {
        logger.debug('getEvalExtractors - modelRef provided, using default extractors');
        return Promise.resolve(DEFAULT_MODEL_EXTRACTORS);
    }
    const config = await findToolsConfig();
    logger.info(`Found tools config... ${JSON.stringify(config)}`);
    const extractors = config?.evaluators
        ?.filter((e) => e.actionRef === actionRef)
        .map((e) => e.extractors);
    if (!extractors) {
        return Promise.resolve(DEFAULT_FLOW_EXTRACTORS);
    }
    let composedExtractors = DEFAULT_FLOW_EXTRACTORS;
    for (const extractor of extractors) {
        const extractorFunction = getExtractorMap(extractor);
        composedExtractors = { ...composedExtractors, ...extractorFunction };
    }
    return Promise.resolve(composedExtractors);
}
export function generateTestCaseId() {
    return randomUUID();
}
//# sourceMappingURL=eval.js.map