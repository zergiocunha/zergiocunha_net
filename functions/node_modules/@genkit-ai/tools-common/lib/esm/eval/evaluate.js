import { randomUUID } from 'crypto';
import { getDatasetStore, getEvalStore } from '.';
import { EvalInferenceInputSchema, FlowActionInputSchema, GenerateRequestSchema, GenerateResponseSchema, } from '../types';
import { evaluatorName, generateTestCaseId, getEvalExtractors, isEvaluator, logger, stackTraceSpans, } from '../utils';
import { enrichResultsWithScoring, extractMetricsMetadata } from './parser';
const SUPPORTED_ACTION_TYPES = ['flow', 'model'];
export async function runNewEvaluation(manager, request) {
    const { datasetId, actionRef, evaluators } = request;
    const datasetStore = await getDatasetStore();
    logger.info(`Fetching dataset ${datasetId}...`);
    const dataset = await datasetStore.getDataset(datasetId);
    const datasetMetadatas = await datasetStore.listDatasets();
    const targetDatasetMetadata = datasetMetadatas.find((d) => d.datasetId === datasetId);
    const datasetVersion = targetDatasetMetadata?.version;
    logger.info('Running inference...');
    const evalDataset = await runInference({
        manager,
        actionRef,
        evalFlowInput: EvalInferenceInputSchema.parse({ samples: dataset }),
        auth: request.options?.auth,
        actionConfig: request.options?.actionConfig,
    });
    const evaluatorActions = await getMatchingEvaluatorActions(manager, evaluators);
    const evalRun = await runEvaluation({
        manager,
        evaluatorActions,
        evalDataset,
        augments: { actionRef, datasetId, datasetVersion },
    });
    return evalRun.key;
}
export async function runInference(params) {
    const { manager, actionRef, evalFlowInput, auth, actionConfig } = params;
    if (!isSupportedActionRef(actionRef)) {
        throw new Error('Inference is only supported on flows and models');
    }
    const evalDataset = await bulkRunAction({
        manager,
        actionRef,
        evalFlowInput,
        auth,
        actionConfig,
    });
    return evalDataset;
}
export async function runEvaluation(params) {
    const { manager, evaluatorActions, evalDataset, augments } = params;
    const evalRunId = randomUUID();
    const scores = {};
    logger.info('Running evaluation...');
    for (const action of evaluatorActions) {
        const name = evaluatorName(action);
        const response = await manager.runAction({
            key: name,
            input: {
                dataset: evalDataset.filter((row) => !row.error),
                evalRunId,
            },
        });
        scores[name] = response.result;
    }
    const scoredResults = enrichResultsWithScoring(scores, evalDataset);
    const metadata = extractMetricsMetadata(evaluatorActions);
    const evalRun = {
        key: {
            evalRunId,
            createdAt: new Date().toISOString(),
            ...augments,
        },
        results: scoredResults,
        metricsMetadata: metadata,
    };
    logger.info('Finished evaluation, writing key...');
    const evalStore = getEvalStore();
    await evalStore.save(evalRun);
    return evalRun;
}
export async function getAllEvaluatorActions(manager) {
    const allActions = await manager.listActions();
    const allEvaluatorActions = [];
    for (const key in allActions) {
        if (isEvaluator(key)) {
            allEvaluatorActions.push(allActions[key]);
        }
    }
    return allEvaluatorActions;
}
export async function getMatchingEvaluatorActions(manager, evaluators) {
    if (!evaluators) {
        return [];
    }
    const allEvaluatorActions = await getAllEvaluatorActions(manager);
    const filteredEvaluatorActions = allEvaluatorActions.filter((action) => evaluators.includes(action.key));
    if (filteredEvaluatorActions.length === 0) {
        if (allEvaluatorActions.length == 0) {
            throw new Error('No evaluators installed');
        }
    }
    return filteredEvaluatorActions;
}
async function bulkRunAction(params) {
    const { manager, actionRef, evalFlowInput, auth, actionConfig } = params;
    const isModelAction = actionRef.startsWith('/model');
    let testCases = Array.isArray(evalFlowInput)
        ? evalFlowInput.map((i) => ({
            input: i,
            testCaseId: generateTestCaseId(),
        }))
        : evalFlowInput.samples.map((c) => ({
            input: c.input,
            reference: c.reference,
            testCaseId: c.testCaseId ?? generateTestCaseId(),
        }));
    let states = [];
    let evalInputs = [];
    for (const testCase of testCases) {
        logger.info(`Running inference '${actionRef}' ...`);
        if (isModelAction) {
            states.push(await runModelAction({
                manager,
                actionRef,
                testCase,
                modelConfig: actionConfig,
            }));
        }
        else {
            states.push(await runFlowAction({
                manager,
                actionRef,
                testCase,
                auth,
            }));
        }
    }
    logger.info(`Gathering evalInputs...`);
    for (const state of states) {
        evalInputs.push(await gatherEvalInput({ manager, actionRef, state }));
    }
    return evalInputs;
}
async function runFlowAction(params) {
    const { manager, actionRef, testCase, auth } = { ...params };
    let state;
    try {
        const flowInput = FlowActionInputSchema.parse({
            start: {
                input: testCase.input,
            },
            auth: auth ? JSON.parse(auth) : undefined,
        });
        const runActionResponse = await manager.runAction({
            key: actionRef,
            input: flowInput,
        });
        state = {
            ...testCase,
            traceId: runActionResponse.telemetry?.traceId,
            response: runActionResponse.result,
        };
    }
    catch (e) {
        const traceId = e?.data?.details?.traceId;
        state = {
            ...testCase,
            traceId,
            evalError: `Error when running inference. Details: ${e?.message ?? e}`,
        };
    }
    return state;
}
async function runModelAction(params) {
    const { manager, actionRef, modelConfig, testCase } = { ...params };
    let state;
    try {
        const modelInput = getModelInput(testCase.input, modelConfig);
        const runActionResponse = await manager.runAction({
            key: actionRef,
            input: modelInput,
        });
        state = {
            ...testCase,
            traceId: runActionResponse.telemetry?.traceId,
            response: runActionResponse.result,
        };
    }
    catch (e) {
        const traceId = e?.data?.details?.traceId;
        state = {
            ...testCase,
            traceId,
            evalError: `Error when running inference. Details: ${e?.message ?? e}`,
        };
    }
    return state;
}
async function gatherEvalInput(params) {
    const { manager, actionRef, state } = params;
    const extractors = await getEvalExtractors(actionRef);
    const traceId = state.traceId;
    if (!traceId) {
        logger.warn('No traceId available...');
        return {
            ...state,
            error: state.evalError,
            testCaseId: randomUUID(),
            traceIds: [],
        };
    }
    const trace = await manager.getTrace({
        traceId,
    });
    const isModelAction = actionRef.startsWith('/model');
    const input = isModelAction ? state.input : extractors.input(trace);
    const nestedSpan = stackTraceSpans(trace);
    if (!nestedSpan) {
        return {
            testCaseId: state.testCaseId,
            input,
            error: `Unable to extract any spans from trace ${traceId}`,
            reference: state.reference,
            traceIds: [traceId],
        };
    }
    if (nestedSpan.attributes['genkit:state'] === 'error') {
        return {
            testCaseId: state.testCaseId,
            input,
            error: getSpanErrorMessage(nestedSpan) ?? `Unknown error in trace ${traceId}`,
            reference: state.reference,
            traceIds: [traceId],
        };
    }
    const output = extractors.output(trace);
    const context = extractors.context(trace);
    const error = isModelAction ? getErrorFromModelResponse(output) : undefined;
    return {
        testCaseId: state.testCaseId,
        input,
        output,
        error,
        context: JSON.parse(context),
        reference: state.reference,
        traceIds: [traceId],
    };
}
function getSpanErrorMessage(span) {
    if (span && span.status?.code === 2) {
        const event = span.timeEvents?.timeEvent
            ?.filter((e) => e.annotation.description === 'exception')
            .shift();
        return (event?.annotation?.attributes['exception.message'] ?? 'Error');
    }
}
function getErrorFromModelResponse(output) {
    const obj = JSON.parse(output);
    const response = GenerateResponseSchema.parse(obj);
    if (!response || !response.candidates || response.candidates.length === 0) {
        return `No response was extracted from the output. '${output}'`;
    }
    const candidate = response.candidates[0];
    if (candidate.finishReason === 'blocked') {
        return candidate.finishMessage || `Generation was blocked by the model.`;
    }
}
function isSupportedActionRef(actionRef) {
    return SUPPORTED_ACTION_TYPES.some((supportedType) => actionRef.startsWith(`/${supportedType}`));
}
function getModelInput(data, modelConfig) {
    let message;
    if (typeof data === 'string') {
        message = {
            role: 'user',
            content: [
                {
                    text: data,
                },
            ],
        };
        return {
            messages: message ? [message] : [],
            config: modelConfig,
        };
    }
    else {
        const maybeRequest = GenerateRequestSchema.safeParse(data);
        if (maybeRequest.success) {
            return maybeRequest.data;
        }
        else {
            throw new Error(`Unable to parse model input as MessageSchema as input. Details: ${maybeRequest.error}`);
        }
    }
}
//# sourceMappingURL=evaluate.js.map