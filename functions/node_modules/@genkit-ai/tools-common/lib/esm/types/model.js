import { z } from 'zod';
import { DocumentDataSchema } from './document';
const EmptyPartSchema = z.object({
    text: z.never().optional(),
    media: z.never().optional(),
    toolRequest: z.never().optional(),
    toolResponse: z.never().optional(),
    data: z.unknown().optional(),
    metadata: z.record(z.unknown()).optional(),
});
export const TextPartSchema = EmptyPartSchema.extend({
    text: z.string(),
});
export const MediaPartSchema = EmptyPartSchema.extend({
    media: z.object({
        contentType: z.string().optional(),
        url: z.string(),
    }),
});
export const ToolRequestPartSchema = EmptyPartSchema.extend({
    toolRequest: z.object({
        ref: z.string().optional(),
        name: z.string(),
        input: z.unknown().optional(),
    }),
});
export const ToolResponsePartSchema = EmptyPartSchema.extend({
    toolResponse: z.object({
        ref: z.string().optional(),
        name: z.string(),
        output: z.unknown().optional(),
    }),
});
export const DataPartSchema = EmptyPartSchema.extend({
    data: z.unknown(),
});
export const PartSchema = z.union([
    TextPartSchema,
    MediaPartSchema,
    ToolRequestPartSchema,
    ToolResponsePartSchema,
    DataPartSchema,
]);
export const RoleSchema = z.enum(['system', 'user', 'model', 'tool']);
export const MessageSchema = z.object({
    role: RoleSchema,
    content: z.array(PartSchema),
    metadata: z.record(z.unknown()).optional(),
});
const OutputFormatSchema = z.enum(['json', 'text', 'media']);
export const ModelInfoSchema = z.object({
    versions: z.array(z.string()).optional(),
    label: z.string().optional(),
    supports: z
        .object({
        multiturn: z.boolean().optional(),
        media: z.boolean().optional(),
        tools: z.boolean().optional(),
        systemRole: z.boolean().optional(),
        output: z.array(OutputFormatSchema).optional(),
        context: z.boolean().optional(),
    })
        .optional(),
});
export const ToolDefinitionSchema = z.object({
    name: z.string(),
    description: z.string(),
    inputSchema: z
        .record(z.any())
        .describe('Valid JSON Schema representing the input of the tool.'),
    outputSchema: z
        .record(z.any())
        .describe('Valid JSON Schema describing the output of the tool.')
        .optional(),
    metadata: z
        .record(z.any())
        .describe('additional metadata for this tool definition')
        .optional(),
});
export const GenerationCommonConfigSchema = z.object({
    version: z.string().optional(),
    temperature: z.number().optional(),
    maxOutputTokens: z.number().optional(),
    topK: z.number().optional(),
    topP: z.number().optional(),
    stopSequences: z.array(z.string()).optional(),
});
const OutputConfigSchema = z.object({
    format: OutputFormatSchema.optional(),
    schema: z.record(z.any()).optional(),
});
export const ModelRequestSchema = z.object({
    messages: z.array(MessageSchema),
    config: z.any().optional(),
    tools: z.array(ToolDefinitionSchema).optional(),
    output: OutputConfigSchema.optional(),
    context: z.array(DocumentDataSchema).optional(),
});
export const GenerateRequestSchema = ModelRequestSchema.extend({
    context: z.array(DocumentDataSchema).optional(),
    candidates: z.number().optional(),
});
export const GenerationUsageSchema = z.object({
    inputTokens: z.number().optional(),
    outputTokens: z.number().optional(),
    totalTokens: z.number().optional(),
    inputCharacters: z.number().optional(),
    outputCharacters: z.number().optional(),
    inputImages: z.number().optional(),
    outputImages: z.number().optional(),
    inputVideos: z.number().optional(),
    outputVideos: z.number().optional(),
    inputAudioFiles: z.number().optional(),
    outputAudioFiles: z.number().optional(),
    custom: z.record(z.number()).optional(),
});
export const CandidateSchema = z.object({
    index: z.number(),
    message: MessageSchema,
    usage: GenerationUsageSchema.optional(),
    finishReason: z.enum(['stop', 'length', 'blocked', 'other', 'unknown']),
    finishMessage: z.string().optional(),
    custom: z.unknown(),
});
export const CandidateErrorSchema = z.object({
    index: z.number(),
    code: z.enum(['blocked', 'other', 'unknown']),
    message: z.string().optional(),
});
export const ModelResponseSchema = z.object({
    message: MessageSchema.optional(),
    finishReason: z.enum(['stop', 'length', 'blocked', 'other', 'unknown']),
    finishMessage: z.string().optional(),
    latencyMs: z.number().optional(),
    usage: GenerationUsageSchema.optional(),
    custom: z.unknown(),
    request: GenerateRequestSchema.optional(),
});
export const GenerateResponseSchema = ModelResponseSchema.extend({
    candidates: z.array(CandidateSchema).optional(),
    finishReason: z
        .enum(['stop', 'length', 'blocked', 'other', 'unknown'])
        .optional(),
});
export const ModelResponseChunkSchema = z.object({
    content: z.array(PartSchema),
    custom: z.unknown().optional(),
    aggregated: z.boolean().optional(),
});
export const GenerateResponseChunkSchema = ModelResponseChunkSchema.extend({
    index: z.number(),
});
//# sourceMappingURL=model.js.map