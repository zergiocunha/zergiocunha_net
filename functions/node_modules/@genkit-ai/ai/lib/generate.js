"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
var generate_exports = {};
__export(generate_exports, {
  GenerateResponse: () => import_response.GenerateResponse,
  GenerateResponseChunk: () => import_chunk.GenerateResponseChunk,
  GenerationBlockedError: () => GenerationBlockedError,
  GenerationResponseError: () => GenerationResponseError,
  generate: () => generate,
  generateStream: () => generateStream,
  tagAsPreamble: () => tagAsPreamble,
  toGenerateRequest: () => toGenerateRequest
});
module.exports = __toCommonJS(generate_exports);
var import_core = require("@genkit-ai/core");
var import_schema = require("@genkit-ai/core/schema");
var import_formats = require("./formats/index.js");
var import_action = require("./generate/action.js");
var import_chunk = require("./generate/chunk.js");
var import_response = require("./generate/response.js");
var import_message = require("./message.js");
var import_model = require("./model.js");
var import_tool = require("./tool.js");
function toGenerateRequest(registry, options) {
  return __async(this, null, function* () {
    var _a, _b, _c;
    const messages = [];
    if (options.system) {
      messages.push({
        role: "system",
        content: import_message.Message.parseContent(options.system)
      });
    }
    if (options.messages) {
      messages.push(...options.messages.map((m) => import_message.Message.parseData(m)));
    }
    if (options.prompt) {
      messages.push({
        role: "user",
        content: import_message.Message.parseContent(options.prompt)
      });
    }
    if (messages.length === 0) {
      throw new import_core.GenkitError({
        status: "INVALID_ARGUMENT",
        message: "at least one message is required in generate request"
      });
    }
    let tools;
    if (options.tools) {
      tools = yield (0, import_tool.resolveTools)(registry, options.tools);
    }
    const resolvedSchema = (0, import_schema.toJsonSchema)({
      schema: (_a = options.output) == null ? void 0 : _a.schema,
      jsonSchema: (_b = options.output) == null ? void 0 : _b.jsonSchema
    });
    const resolvedFormat = yield (0, import_formats.resolveFormat)(registry, options.output);
    const instructions = (0, import_formats.resolveInstructions)(
      resolvedFormat,
      resolvedSchema,
      (_c = options == null ? void 0 : options.output) == null ? void 0 : _c.instructions
    );
    const out = {
      messages: (0, import_formats.injectInstructions)(messages, instructions),
      config: options.config,
      docs: options.docs,
      tools: (tools == null ? void 0 : tools.map(import_tool.toToolDefinition)) || [],
      output: __spreadProps(__spreadValues({}, (resolvedFormat == null ? void 0 : resolvedFormat.config) || {}), {
        schema: resolvedSchema
      })
    };
    if (!out.output.schema) delete out.output.schema;
    return out;
  });
}
class GenerationResponseError extends import_core.GenkitError {
  constructor(response, message, status, detail) {
    super({
      status: status || "FAILED_PRECONDITION",
      message
    });
    this.detail = __spreadValues({ response }, detail);
  }
}
function toolsToActionRefs(registry, toolOpt) {
  return __async(this, null, function* () {
    var _a;
    if (!toolOpt) return;
    let tools = [];
    for (const t of toolOpt) {
      if (typeof t === "string") {
        tools.push(yield resolveFullToolName(registry, t));
      } else if (t.__action) {
        tools.push(
          `/${(_a = t.__action.metadata) == null ? void 0 : _a.type}/${t.__action.name}`
        );
      } else if (typeof t.asTool === "function") {
        const promptToolAction = yield t.asTool();
        tools.push(`/prompt/${promptToolAction.__action.name}`);
      } else if (t.name) {
        tools.push(yield resolveFullToolName(registry, t.name));
      } else {
        throw new Error(`Unable to determine type of tool: ${JSON.stringify(t)}`);
      }
    }
    return tools;
  });
}
function messagesFromOptions(options) {
  const messages = [];
  if (options.system) {
    messages.push({
      role: "system",
      content: import_message.Message.parseContent(options.system)
    });
  }
  if (options.messages) {
    messages.push(...options.messages);
  }
  if (options.prompt) {
    messages.push({
      role: "user",
      content: import_message.Message.parseContent(options.prompt)
    });
  }
  if (messages.length === 0) {
    throw new import_core.GenkitError({
      status: "INVALID_ARGUMENT",
      message: "at least one message is required in generate request"
    });
  }
  return messages;
}
class GenerationBlockedError extends GenerationResponseError {
}
function generate(registry, options) {
  return __async(this, null, function* () {
    var _a, _b, _c, _d, _e;
    const resolvedOptions = __spreadValues({}, yield Promise.resolve(options));
    const resolvedModel = yield (0, import_model.resolveModel)(registry, resolvedOptions.model);
    const tools = yield toolsToActionRefs(registry, resolvedOptions.tools);
    const messages = messagesFromOptions(resolvedOptions);
    const resolvedSchema = (0, import_schema.toJsonSchema)({
      schema: (_a = resolvedOptions.output) == null ? void 0 : _a.schema,
      jsonSchema: (_b = resolvedOptions.output) == null ? void 0 : _b.jsonSchema
    });
    if (((_c = resolvedOptions.output) == null ? void 0 : _c.schema) && !((_d = resolvedOptions.output) == null ? void 0 : _d.format)) {
      resolvedOptions.output.format = "json";
    }
    const resolvedFormat = yield (0, import_formats.resolveFormat)(registry, resolvedOptions.output);
    const instructions = (0, import_formats.resolveInstructions)(
      resolvedFormat,
      resolvedSchema,
      (_e = resolvedOptions == null ? void 0 : resolvedOptions.output) == null ? void 0 : _e.instructions
    );
    const params = {
      model: resolvedModel.modelAction.__action.name,
      docs: resolvedOptions.docs,
      messages: (0, import_formats.injectInstructions)(messages, instructions),
      tools,
      config: __spreadValues(__spreadValues({
        version: resolvedModel.version
      }, stripUndefinedOptions(resolvedModel.config)), stripUndefinedOptions(resolvedOptions.config)),
      output: resolvedOptions.output && {
        format: resolvedOptions.output.format,
        jsonSchema: resolvedSchema
      },
      returnToolRequests: resolvedOptions.returnToolRequests
    };
    return yield (0, import_core.runWithStreamingCallback)(
      resolvedOptions.streamingCallback,
      () => __async(this, null, function* () {
        var _a2, _b2;
        const response = yield (0, import_action.generateHelper)(
          registry,
          params,
          resolvedOptions.use
        );
        const request = yield toGenerateRequest(registry, __spreadProps(__spreadValues({}, resolvedOptions), {
          tools
        }));
        return new import_response.GenerateResponse(response, {
          request: (_a2 = response.request) != null ? _a2 : request,
          parser: resolvedFormat == null ? void 0 : resolvedFormat.handler((_b2 = request.output) == null ? void 0 : _b2.schema).parseMessage
        });
      })
    );
  });
}
function stripUndefinedOptions(input) {
  if (!input) return input;
  const copy = __spreadValues({}, input);
  Object.keys(input).forEach((key) => {
    if (copy[key] === void 0) {
      delete copy[key];
    }
  });
  return copy;
}
function resolveFullToolName(registry, name) {
  return __async(this, null, function* () {
    if (yield registry.lookupAction(`/tool/${name}`)) {
      return `/tool/${name}`;
    } else if (yield registry.lookupAction(`/prompt/${name}`)) {
      return `/prompt/${name}`;
    } else {
      throw new Error(`Unable to determine type of of tool: ${name}`);
    }
  });
}
function createPromise() {
  let resolve, reject;
  let promise = new Promise((res, rej) => [resolve, reject] = [res, rej]);
  return { resolve, reject, promise };
}
function generateStream(registry, options) {
  return __async(this, null, function* () {
    let firstChunkSent = false;
    return new Promise(
      (initialResolve, initialReject) => {
        const {
          resolve: finalResolve,
          reject: finalReject,
          promise: finalPromise
        } = createPromise();
        let provideNextChunk, nextChunk;
        ({ resolve: provideNextChunk, promise: nextChunk } = createPromise());
        function chunkStream() {
          return __asyncGenerator(this, null, function* () {
            while (true) {
              const next = yield new __await(nextChunk);
              if (!next) break;
              yield next;
            }
          });
        }
        try {
          generate(registry, __spreadProps(__spreadValues({}, options), {
            streamingCallback: (chunk) => {
              firstChunkSent = true;
              provideNextChunk(chunk);
              ({ resolve: provideNextChunk, promise: nextChunk } = createPromise());
            }
          })).then((result) => {
            provideNextChunk(null);
            finalResolve(result);
          }).catch((e) => {
            if (!firstChunkSent) {
              initialReject(e);
              return;
            }
            provideNextChunk(null);
            finalReject(e);
          });
        } catch (e) {
          if (!firstChunkSent) {
            initialReject(e);
            return;
          }
          provideNextChunk(null);
          finalReject(e);
        }
        initialResolve({
          get response() {
            return finalPromise;
          },
          get stream() {
            return chunkStream();
          }
        });
      }
    );
  });
}
function tagAsPreamble(msgs) {
  if (!msgs) {
    return void 0;
  }
  return msgs.map((m) => __spreadProps(__spreadValues({}, m), {
    metadata: __spreadProps(__spreadValues({}, m.metadata), {
      preamble: true
    })
  }));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GenerateResponse,
  GenerateResponseChunk,
  GenerationBlockedError,
  GenerationResponseError,
  generate,
  generateStream,
  tagAsPreamble,
  toGenerateRequest
});
//# sourceMappingURL=generate.js.map