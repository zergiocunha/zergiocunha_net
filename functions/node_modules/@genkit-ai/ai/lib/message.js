"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var message_exports = {};
__export(message_exports, {
  Message: () => Message
});
module.exports = __toCommonJS(message_exports);
var import_extract = require("./extract");
class Message {
  static parseData(lenientMessage, defaultRole = "user") {
    if (typeof lenientMessage === "string") {
      return { role: defaultRole, content: [{ text: lenientMessage }] };
    }
    return __spreadProps(__spreadValues({}, lenientMessage), {
      content: Message.parseContent(lenientMessage.content)
    });
  }
  static parse(lenientMessage) {
    return new Message(Message.parseData(lenientMessage));
  }
  static parseContent(lenientPart) {
    if (typeof lenientPart === "string") {
      return [{ text: lenientPart }];
    } else if (Array.isArray(lenientPart)) {
      return lenientPart.map((p) => typeof p === "string" ? { text: p } : p);
    } else {
      return [lenientPart];
    }
  }
  constructor(message, options) {
    this.role = message.role;
    this.content = message.content;
    this.metadata = message.metadata;
    this.parser = options == null ? void 0 : options.parser;
  }
  /**
   * Attempts to parse the content of the message according to the supplied
   * output parser. Without a parser, returns `data` contained in the message or
   * tries to parse JSON from the text of the message.
   *
   * @returns The structured output contained in the message.
   */
  get output() {
    var _a;
    return ((_a = this.parser) == null ? void 0 : _a.call(this, this)) || this.data || (0, import_extract.extractJson)(this.text);
  }
  toolResponseParts() {
    const res = this.content.filter((part) => !!part.toolResponse);
    return res;
  }
  /**
   * Concatenates all `text` parts present in the message with no delimiter.
   * @returns A string of all concatenated text parts.
   */
  get text() {
    return this.content.map((part) => part.text || "").join("");
  }
  /**
   * Returns the first media part detected in the message. Useful for extracting
   * (for example) an image from a generation expected to create one.
   * @returns The first detected `media` part in the message.
   */
  get media() {
    var _a;
    return ((_a = this.content.find((part) => part.media)) == null ? void 0 : _a.media) || null;
  }
  /**
   * Returns the first detected `data` part of a message.
   * @returns The first `data` part detected in the message (if any).
   */
  get data() {
    var _a;
    return (_a = this.content.find((part) => part.data)) == null ? void 0 : _a.data;
  }
  /**
   * Returns all tool request found in this message.
   * @returns Array of all tool request found in this message.
   */
  get toolRequests() {
    return this.content.filter(
      (part) => !!part.toolRequest
    );
  }
  /**
   * Converts the Message to a plain JS object.
   * @returns Plain JS object representing the data contained in the message.
   */
  toJSON() {
    let out = {
      role: this.role,
      content: [...this.content]
    };
    if (this.metadata) out.metadata = this.metadata;
    return out;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Message
});
//# sourceMappingURL=message.js.map