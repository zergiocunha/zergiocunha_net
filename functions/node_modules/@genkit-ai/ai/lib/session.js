"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var session_exports = {};
__export(session_exports, {
  Session: () => Session,
  SessionError: () => SessionError,
  getCurrentSession: () => getCurrentSession,
  inMemorySessionStore: () => inMemorySessionStore,
  runWithSession: () => runWithSession
});
module.exports = __toCommonJS(session_exports);
var import_node_async_hooks = require("node:async_hooks");
var import_uuid = require("uuid");
var import_chat = require("./chat");
var import_index = require("./index.js");
class Session {
  constructor(registry, options) {
    this.registry = registry;
    var _a, _b, _c;
    this.id = (_a = options == null ? void 0 : options.id) != null ? _a : (0, import_uuid.v4)();
    this.sessionData = (_b = options == null ? void 0 : options.sessionData) != null ? _b : {
      id: this.id
    };
    if (!this.sessionData) {
      this.sessionData = { id: this.id };
    }
    if (!this.sessionData.threads) {
      this.sessionData.threads = {};
    }
    this.store = (_c = options == null ? void 0 : options.store) != null ? _c : new InMemorySessionStore();
  }
  get state() {
    return this.sessionData.state;
  }
  /**
   * Update session state data.
   */
  updateState(data) {
    return __async(this, null, function* () {
      let sessionData = this.sessionData;
      if (!sessionData) {
        sessionData = {};
      }
      sessionData.state = data;
      this.sessionData = sessionData;
      yield this.store.save(this.id, sessionData);
    });
  }
  /**
   * Update messages for a given thread.
   */
  updateMessages(thread, messages) {
    return __async(this, null, function* () {
      let sessionData = this.sessionData;
      if (!sessionData) {
        sessionData = {};
      }
      if (!sessionData.threads) {
        sessionData.threads = {};
      }
      sessionData.threads[thread] = messages.map(
        (m) => m.toJSON ? m.toJSON() : m
      );
      this.sessionData = sessionData;
      yield this.store.save(this.id, sessionData);
    });
  }
  chat(optionsOrPreambleOrThreadName, maybeOptionsOrPreamble, maybeOptions) {
    return runWithSession(this, () => {
      var _a, _b, _c;
      let options;
      let threadName = import_chat.MAIN_THREAD;
      let preamble;
      if (optionsOrPreambleOrThreadName) {
        if (typeof optionsOrPreambleOrThreadName === "string") {
          threadName = optionsOrPreambleOrThreadName;
        } else if ((0, import_index.isExecutablePrompt)(optionsOrPreambleOrThreadName)) {
          preamble = optionsOrPreambleOrThreadName;
        } else {
          options = optionsOrPreambleOrThreadName;
        }
      }
      if (maybeOptionsOrPreamble) {
        if ((0, import_index.isExecutablePrompt)(maybeOptionsOrPreamble)) {
          preamble = maybeOptionsOrPreamble;
        } else {
          options = maybeOptionsOrPreamble;
        }
      }
      if (maybeOptions) {
        options = maybeOptions;
      }
      let requestBase;
      if (preamble) {
        const renderOptions = options;
        requestBase = preamble.render({
          input: renderOptions == null ? void 0 : renderOptions.input,
          model: renderOptions == null ? void 0 : renderOptions.model,
          config: renderOptions == null ? void 0 : renderOptions.config,
          messages: renderOptions == null ? void 0 : renderOptions.messages
        }).then((rb) => {
          return __spreadProps(__spreadValues({}, rb), {
            messages: (0, import_index.tagAsPreamble)(rb == null ? void 0 : rb.messages)
          });
        });
      } else {
        const baseOptions = __spreadValues({}, options);
        const messages = [];
        if (baseOptions.system) {
          messages.push({
            role: "system",
            content: import_index.Message.parseContent(baseOptions.system)
          });
        }
        delete baseOptions.system;
        if (baseOptions.messages) {
          messages.push(...baseOptions.messages);
        }
        baseOptions.messages = (0, import_index.tagAsPreamble)(messages);
        requestBase = Promise.resolve(baseOptions);
      }
      return new import_chat.Chat(this, requestBase, {
        thread: threadName,
        id: this.id,
        messages: (_c = ((_a = this.sessionData) == null ? void 0 : _a.threads) && ((_b = this.sessionData) == null ? void 0 : _b.threads[threadName])) != null ? _c : []
      });
    });
  }
  /**
   * Executes provided function within this session context allowing calling
   * `ai.currentSession().state`
   */
  run(fn) {
    return runWithSession(this, fn);
  }
  toJSON() {
    return this.sessionData;
  }
}
const sessionAls = new import_node_async_hooks.AsyncLocalStorage();
function runWithSession(session, fn) {
  return sessionAls.run(session, fn);
}
function getCurrentSession() {
  return sessionAls.getStore();
}
class SessionError extends Error {
  constructor(msg) {
    super(msg);
  }
}
function inMemorySessionStore() {
  return new InMemorySessionStore();
}
class InMemorySessionStore {
  constructor() {
    this.data = {};
  }
  get(sessionId) {
    return __async(this, null, function* () {
      return this.data[sessionId];
    });
  }
  save(sessionId, sessionData) {
    return __async(this, null, function* () {
      this.data[sessionId] = sessionData;
    });
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Session,
  SessionError,
  getCurrentSession,
  inMemorySessionStore,
  runWithSession
});
//# sourceMappingURL=session.js.map