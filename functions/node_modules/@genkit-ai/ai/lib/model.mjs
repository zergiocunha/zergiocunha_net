import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-7LUMLJGI.mjs";
import {
  defineAction,
  GenkitError,
  getStreamingCallback,
  z
} from "@genkit-ai/core";
import { toJsonSchema } from "@genkit-ai/core/schema";
import { performance } from "node:perf_hooks";
import { DocumentDataSchema } from "./document.js";
import { augmentWithContext, validateSupport } from "./model/middleware.js";
const EmptyPartSchema = z.object({
  text: z.never().optional(),
  media: z.never().optional(),
  toolRequest: z.never().optional(),
  toolResponse: z.never().optional(),
  data: z.unknown().optional(),
  metadata: z.record(z.unknown()).optional(),
  custom: z.record(z.unknown()).optional()
});
const TextPartSchema = EmptyPartSchema.extend({
  /** The text of the message. */
  text: z.string()
});
const MediaPartSchema = EmptyPartSchema.extend({
  media: z.object({
    /** The media content type. Inferred from data uri if not provided. */
    contentType: z.string().optional(),
    /** A `data:` or `https:` uri containing the media content.  */
    url: z.string()
  })
});
const ToolRequestPartSchema = EmptyPartSchema.extend({
  /** A request for a tool to be executed, usually provided by a model. */
  toolRequest: z.object({
    /** The call id or reference for a specific request. */
    ref: z.string().optional(),
    /** The name of the tool to call. */
    name: z.string(),
    /** The input parameters for the tool, usually a JSON object. */
    input: z.unknown().optional()
  })
});
const ToolResponsePartSchema = EmptyPartSchema.extend({
  /** A provided response to a tool call. */
  toolResponse: z.object({
    /** The call id or reference for a specific request. */
    ref: z.string().optional(),
    /** The name of the tool. */
    name: z.string(),
    /** The output data returned from the tool, usually a JSON object. */
    output: z.unknown().optional()
  })
});
const DataPartSchema = EmptyPartSchema.extend({
  data: z.unknown()
});
const CustomPartSchema = EmptyPartSchema.extend({
  custom: z.record(z.any())
});
const PartSchema = z.union([
  TextPartSchema,
  MediaPartSchema,
  ToolRequestPartSchema,
  ToolResponsePartSchema,
  DataPartSchema,
  CustomPartSchema
]);
const RoleSchema = z.enum(["system", "user", "model", "tool"]);
const MessageSchema = z.object({
  role: RoleSchema,
  content: z.array(PartSchema),
  metadata: z.record(z.unknown()).optional()
});
const ModelInfoSchema = z.object({
  /** Acceptable names for this model (e.g. different versions). */
  versions: z.array(z.string()).optional(),
  /** Friendly label for this model (e.g. "Google AI - Gemini Pro") */
  label: z.string().optional(),
  /** Supported model capabilities. */
  supports: z.object({
    /** Model can process historical messages passed with a prompt. */
    multiturn: z.boolean().optional(),
    /** Model can process media as part of the prompt (multimodal input). */
    media: z.boolean().optional(),
    /** Model can perform tool calls. */
    tools: z.boolean().optional(),
    /** Model can accept messages with role "system". */
    systemRole: z.boolean().optional(),
    /** Model can output this type of data. */
    output: z.array(z.string()).optional(),
    /** Model supports output in these content types. */
    contentType: z.array(z.string()).optional(),
    /** Model can natively support document-based context grounding. */
    context: z.boolean().optional()
  }).optional(),
  /** At which stage of development this model is.
   * - `featured` models are recommended for general use.
   * - `stable` models are well-tested and reliable.
   * - `unstable` models are experimental and may change.
   * - `legacy` models are no longer recommended for new projects.
   * - `deprecated` models are deprecated by the provider and may be removed in future versions.
   */
  stage: z.enum(["featured", "stable", "unstable", "legacy", "deprecated"]).optional()
});
const ToolDefinitionSchema = z.object({
  name: z.string(),
  description: z.string(),
  inputSchema: z.record(z.any()).describe("Valid JSON Schema representing the input of the tool.").nullish(),
  outputSchema: z.record(z.any()).describe("Valid JSON Schema describing the output of the tool.").nullish(),
  metadata: z.record(z.any()).describe("additional metadata for this tool definition").optional()
});
const GenerationCommonConfigSchema = z.object({
  /** A specific version of a model family, e.g. `gemini-1.0-pro-001` for the `gemini-1.0-pro` family. */
  version: z.string().optional(),
  temperature: z.number().optional(),
  maxOutputTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  stopSequences: z.array(z.string()).optional()
});
const OutputConfigSchema = z.object({
  format: z.string().optional(),
  schema: z.record(z.any()).optional(),
  constrained: z.boolean().optional(),
  instructions: z.string().optional(),
  contentType: z.string().optional()
});
const ModelRequestSchema = z.object({
  messages: z.array(MessageSchema),
  config: z.any().optional(),
  tools: z.array(ToolDefinitionSchema).optional(),
  output: OutputConfigSchema.optional(),
  docs: z.array(DocumentDataSchema).optional()
});
const GenerateRequestSchema = ModelRequestSchema.extend({
  /** @deprecated All responses now return a single candidate. This will always be `undefined`. */
  candidates: z.number().optional()
});
const GenerationUsageSchema = z.object({
  inputTokens: z.number().optional(),
  outputTokens: z.number().optional(),
  totalTokens: z.number().optional(),
  inputCharacters: z.number().optional(),
  outputCharacters: z.number().optional(),
  inputImages: z.number().optional(),
  outputImages: z.number().optional(),
  inputVideos: z.number().optional(),
  outputVideos: z.number().optional(),
  inputAudioFiles: z.number().optional(),
  outputAudioFiles: z.number().optional(),
  custom: z.record(z.number()).optional()
});
const CandidateSchema = z.object({
  index: z.number(),
  message: MessageSchema,
  usage: GenerationUsageSchema.optional(),
  finishReason: z.enum(["stop", "length", "blocked", "other", "unknown"]),
  finishMessage: z.string().optional(),
  custom: z.unknown()
});
const CandidateErrorSchema = z.object({
  index: z.number(),
  code: z.enum(["blocked", "other", "unknown"]),
  message: z.string().optional()
});
const ModelResponseSchema = z.object({
  message: MessageSchema.optional(),
  finishReason: z.enum(["stop", "length", "blocked", "other", "unknown"]),
  finishMessage: z.string().optional(),
  latencyMs: z.number().optional(),
  usage: GenerationUsageSchema.optional(),
  /** @deprecated use `raw` instead */
  custom: z.unknown(),
  raw: z.unknown(),
  request: GenerateRequestSchema.optional()
});
const GenerateResponseSchema = ModelResponseSchema.extend({
  /** @deprecated All responses now return a single candidate. Only the first candidate will be used if supplied. Return `message`, `finishReason`, and `finishMessage` instead. */
  candidates: z.array(CandidateSchema).optional(),
  finishReason: z.enum(["stop", "length", "blocked", "other", "unknown"]).optional()
});
const ModelResponseChunkSchema = z.object({
  /** The chunk of content to stream right now. */
  content: z.array(PartSchema),
  /** Model-specific extra information attached to this chunk. */
  custom: z.unknown().optional(),
  /** If true, the chunk includes all data from previous chunks. Otherwise, considered to be incremental. */
  aggregated: z.boolean().optional()
});
const GenerateResponseChunkSchema = ModelResponseChunkSchema.extend({
  /** @deprecated The index of the candidate this chunk belongs to. Always 0. */
  index: z.number().optional()
});
function defineModel(registry, options, runner) {
  var _a;
  const label = options.label || options.name;
  const middleware = [
    ...options.use || [],
    validateSupport(options)
  ];
  if (!((_a = options == null ? void 0 : options.supports) == null ? void 0 : _a.context)) middleware.push(augmentWithContext());
  const act = defineAction(
    registry,
    {
      actionType: "model",
      name: options.name,
      description: label,
      inputSchema: GenerateRequestSchema,
      outputSchema: GenerateResponseSchema,
      metadata: {
        model: {
          label,
          customOptions: options.configSchema ? toJsonSchema({ schema: options.configSchema }) : void 0,
          versions: options.versions,
          supports: options.supports
        }
      },
      use: middleware
    },
    (input) => {
      const startTimeMs = performance.now();
      return runner(input, getStreamingCallback()).then((response) => {
        const timedResponse = __spreadProps(__spreadValues({}, response), {
          latencyMs: performance.now() - startTimeMs
        });
        return timedResponse;
      });
    }
  );
  Object.assign(act, {
    __configSchema: options.configSchema || z.unknown()
  });
  return act;
}
function modelRef(options) {
  const ref = __spreadValues({}, options);
  ref.withConfig = (cfg) => {
    return modelRef(__spreadProps(__spreadValues({}, options), {
      config: cfg
    }));
  };
  ref.withVersion = (version) => {
    return modelRef(__spreadProps(__spreadValues({}, options), {
      version
    }));
  };
  return ref;
}
function getBasicUsageStats(input, response) {
  const inputCounts = getPartCounts(input.flatMap((md) => md.content));
  const outputCounts = getPartCounts(
    Array.isArray(response) ? response.flatMap((c) => c.message.content) : response.content
  );
  return {
    inputCharacters: inputCounts.characters,
    inputImages: inputCounts.images,
    inputVideos: inputCounts.videos,
    inputAudioFiles: inputCounts.audio,
    outputCharacters: outputCounts.characters,
    outputImages: outputCounts.images,
    outputVideos: outputCounts.videos,
    outputAudioFiles: outputCounts.audio
  };
}
function getPartCounts(parts) {
  return parts.reduce(
    (counts, part) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      const isImage = ((_b = (_a = part.media) == null ? void 0 : _a.contentType) == null ? void 0 : _b.startsWith("image")) || ((_d = (_c = part.media) == null ? void 0 : _c.url) == null ? void 0 : _d.startsWith("data:image"));
      const isVideo = ((_f = (_e = part.media) == null ? void 0 : _e.contentType) == null ? void 0 : _f.startsWith("video")) || ((_h = (_g = part.media) == null ? void 0 : _g.url) == null ? void 0 : _h.startsWith("data:video"));
      const isAudio = ((_j = (_i = part.media) == null ? void 0 : _i.contentType) == null ? void 0 : _j.startsWith("audio")) || ((_l = (_k = part.media) == null ? void 0 : _k.url) == null ? void 0 : _l.startsWith("data:audio"));
      return {
        characters: counts.characters + (((_m = part.text) == null ? void 0 : _m.length) || 0),
        images: counts.images + (isImage ? 1 : 0),
        videos: counts.videos + (isVideo ? 1 : 0),
        audio: counts.audio + (isAudio ? 1 : 0)
      };
    },
    { characters: 0, images: 0, videos: 0, audio: 0 }
  );
}
function resolveModel(registry, model) {
  return __async(this, null, function* () {
    let out;
    let modelId;
    if (!model) {
      model = yield registry.lookupValue("defaultModel", "defaultModel");
    }
    if (!model) {
      throw new GenkitError({
        status: "INVALID_ARGUMENT",
        message: "Must supply a `model` to `generate()` calls."
      });
    }
    if (typeof model === "string") {
      modelId = model;
      out = { modelAction: yield registry.lookupAction(`/model/${model}`) };
    } else if (model.hasOwnProperty("__action")) {
      modelId = model.__action.name;
      out = { modelAction: model };
    } else {
      const ref = model;
      modelId = ref.name;
      out = {
        modelAction: yield registry.lookupAction(
          `/model/${ref.name}`
        ),
        config: __spreadValues({}, ref.config),
        version: ref.version
      };
    }
    if (!out.modelAction) {
      throw new GenkitError({
        status: "NOT_FOUND",
        message: `Model ${modelId} not found`
      });
    }
    return out;
  });
}
export {
  CandidateErrorSchema,
  CandidateSchema,
  CustomPartSchema,
  DataPartSchema,
  GenerateRequestSchema,
  GenerateResponseChunkSchema,
  GenerateResponseSchema,
  GenerationCommonConfigSchema,
  GenerationUsageSchema,
  MediaPartSchema,
  MessageSchema,
  ModelInfoSchema,
  ModelRequestSchema,
  ModelResponseChunkSchema,
  ModelResponseSchema,
  PartSchema,
  RoleSchema,
  TextPartSchema,
  ToolDefinitionSchema,
  ToolRequestPartSchema,
  ToolResponsePartSchema,
  defineModel,
  getBasicUsageStats,
  modelRef,
  resolveModel
};
//# sourceMappingURL=model.mjs.map