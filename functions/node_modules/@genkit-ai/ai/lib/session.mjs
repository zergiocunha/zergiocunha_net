import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-7LUMLJGI.mjs";
import { AsyncLocalStorage } from "node:async_hooks";
import { v4 as uuidv4 } from "uuid";
import { Chat, MAIN_THREAD } from "./chat";
import {
  Message,
  isExecutablePrompt,
  tagAsPreamble
} from "./index.js";
class Session {
  constructor(registry, options) {
    this.registry = registry;
    var _a, _b, _c;
    this.id = (_a = options == null ? void 0 : options.id) != null ? _a : uuidv4();
    this.sessionData = (_b = options == null ? void 0 : options.sessionData) != null ? _b : {
      id: this.id
    };
    if (!this.sessionData) {
      this.sessionData = { id: this.id };
    }
    if (!this.sessionData.threads) {
      this.sessionData.threads = {};
    }
    this.store = (_c = options == null ? void 0 : options.store) != null ? _c : new InMemorySessionStore();
  }
  get state() {
    return this.sessionData.state;
  }
  /**
   * Update session state data.
   */
  updateState(data) {
    return __async(this, null, function* () {
      let sessionData = this.sessionData;
      if (!sessionData) {
        sessionData = {};
      }
      sessionData.state = data;
      this.sessionData = sessionData;
      yield this.store.save(this.id, sessionData);
    });
  }
  /**
   * Update messages for a given thread.
   */
  updateMessages(thread, messages) {
    return __async(this, null, function* () {
      let sessionData = this.sessionData;
      if (!sessionData) {
        sessionData = {};
      }
      if (!sessionData.threads) {
        sessionData.threads = {};
      }
      sessionData.threads[thread] = messages.map(
        (m) => m.toJSON ? m.toJSON() : m
      );
      this.sessionData = sessionData;
      yield this.store.save(this.id, sessionData);
    });
  }
  chat(optionsOrPreambleOrThreadName, maybeOptionsOrPreamble, maybeOptions) {
    return runWithSession(this, () => {
      var _a, _b, _c;
      let options;
      let threadName = MAIN_THREAD;
      let preamble;
      if (optionsOrPreambleOrThreadName) {
        if (typeof optionsOrPreambleOrThreadName === "string") {
          threadName = optionsOrPreambleOrThreadName;
        } else if (isExecutablePrompt(optionsOrPreambleOrThreadName)) {
          preamble = optionsOrPreambleOrThreadName;
        } else {
          options = optionsOrPreambleOrThreadName;
        }
      }
      if (maybeOptionsOrPreamble) {
        if (isExecutablePrompt(maybeOptionsOrPreamble)) {
          preamble = maybeOptionsOrPreamble;
        } else {
          options = maybeOptionsOrPreamble;
        }
      }
      if (maybeOptions) {
        options = maybeOptions;
      }
      let requestBase;
      if (preamble) {
        const renderOptions = options;
        requestBase = preamble.render({
          input: renderOptions == null ? void 0 : renderOptions.input,
          model: renderOptions == null ? void 0 : renderOptions.model,
          config: renderOptions == null ? void 0 : renderOptions.config,
          messages: renderOptions == null ? void 0 : renderOptions.messages
        }).then((rb) => {
          return __spreadProps(__spreadValues({}, rb), {
            messages: tagAsPreamble(rb == null ? void 0 : rb.messages)
          });
        });
      } else {
        const baseOptions = __spreadValues({}, options);
        const messages = [];
        if (baseOptions.system) {
          messages.push({
            role: "system",
            content: Message.parseContent(baseOptions.system)
          });
        }
        delete baseOptions.system;
        if (baseOptions.messages) {
          messages.push(...baseOptions.messages);
        }
        baseOptions.messages = tagAsPreamble(messages);
        requestBase = Promise.resolve(baseOptions);
      }
      return new Chat(this, requestBase, {
        thread: threadName,
        id: this.id,
        messages: (_c = ((_a = this.sessionData) == null ? void 0 : _a.threads) && ((_b = this.sessionData) == null ? void 0 : _b.threads[threadName])) != null ? _c : []
      });
    });
  }
  /**
   * Executes provided function within this session context allowing calling
   * `ai.currentSession().state`
   */
  run(fn) {
    return runWithSession(this, fn);
  }
  toJSON() {
    return this.sessionData;
  }
}
const sessionAls = new AsyncLocalStorage();
function runWithSession(session, fn) {
  return sessionAls.run(session, fn);
}
function getCurrentSession() {
  return sessionAls.getStore();
}
class SessionError extends Error {
  constructor(msg) {
    super(msg);
  }
}
function inMemorySessionStore() {
  return new InMemorySessionStore();
}
class InMemorySessionStore {
  constructor() {
    this.data = {};
  }
  get(sessionId) {
    return __async(this, null, function* () {
      return this.data[sessionId];
    });
  }
  save(sessionId, sessionData) {
    return __async(this, null, function* () {
      this.data[sessionId] = sessionData;
    });
  }
}
export {
  Session,
  SessionError,
  getCurrentSession,
  inMemorySessionStore,
  runWithSession
};
//# sourceMappingURL=session.mjs.map