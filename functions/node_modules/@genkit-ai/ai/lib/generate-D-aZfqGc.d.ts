import { z, Action, JSONSchema7, StreamingCallback, GenkitError } from '@genkit-ai/core';
import { Registry } from '@genkit-ai/core/registry';
import { DocumentData } from './document.js';
import { GenerateResponseChunk } from './generate/chunk.js';
import { GenerateResponse } from './generate/response.js';
import { GenerateRequest, GenerateRequestSchema, GenerateResponseChunkSchema, ModelArgument, ToolDefinition, Part, MessageData, ModelMiddleware, GenerationCommonConfigSchema } from './model.js';

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

type PromptFn<I extends z.ZodTypeAny = z.ZodTypeAny, CustomOptionsSchema extends z.ZodTypeAny = z.ZodTypeAny> = (input: z.infer<I>) => Promise<GenerateRequest<CustomOptionsSchema>>;
type PromptAction<I extends z.ZodTypeAny = z.ZodTypeAny> = Action<I, typeof GenerateRequestSchema, typeof GenerateResponseChunkSchema> & {
    __action: {
        metadata: {
            type: 'prompt';
        };
    };
};
/**
 * Configuration for a prompt action.
 */
interface PromptConfig<I extends z.ZodTypeAny = z.ZodTypeAny> {
    name: string;
    description?: string;
    inputSchema?: I;
    inputJsonSchema?: JSONSchema7;
    metadata?: Record<string, any>;
}
declare function isPrompt(arg: any): boolean;
type PromptGenerateOptions<O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = z.ZodTypeAny> = Omit<GenerateOptions<O, CustomOptions>, 'prompt'>;
/**
 * A prompt that can be executed as a function.
 */
interface ExecutablePrompt<I = undefined, O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = z.ZodTypeAny> {
    /**
     * Generates a response by rendering the prompt template with given user input and then calling the model.
     *
     * @param input Prompt inputs.
     * @param opt Options for the prompt template, including user input variables and custom model configuration options.
     * @returns the model response as a promise of `GenerateStreamResponse`.
     */
    (input?: I, opts?: PromptGenerateOptions<O, CustomOptions>): Promise<GenerateResponse<z.infer<O>>>;
    /**
     * Generates a response by rendering the prompt template with given user input and then calling the model.
     * @param input Prompt inputs.
     * @param opt Options for the prompt template, including user input variables and custom model configuration options.
     * @returns the model response as a promise of `GenerateStreamResponse`.
     */
    stream(input?: I, opts?: PromptGenerateOptions<O, CustomOptions>): Promise<GenerateStreamResponse<z.infer<O>>>;
    /**
     * Renders the prompt template based on user input.
     *
     * @param opt Options for the prompt template, including user input variables and custom model configuration options.
     * @returns a `GenerateOptions` object to be used with the `generate()` function from @genkit-ai/ai.
     */
    render(opt: PromptGenerateOptions<O, CustomOptions> & {
        input?: I;
    }): Promise<GenerateOptions<O, CustomOptions>>;
    /**
     * Returns the prompt usable as a tool.
     */
    asTool(): Promise<ToolAction>;
}
/**
 * Defines and registers a prompt action. The action can be called to obtain
 * a `GenerateRequest` which can be passed to a model action. The given
 * `PromptFn` can perform any action needed to create the request such as rendering
 * a template or fetching a prompt from a database.
 *
 * @returns The new `PromptAction`.
 */
declare function definePrompt<I extends z.ZodTypeAny>(registry: Registry, config: PromptConfig<I>, fn: PromptFn<I>): PromptAction<I>;
type PromptArgument<I extends z.ZodTypeAny = z.ZodTypeAny> = string | PromptAction<I>;
/**
 * This veneer renders a `PromptAction` into a `GenerateOptions` object.
 *
 * @returns A promise of an options object for use with the `generate()` function.
 */
declare function renderPrompt<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = z.ZodTypeAny>(registry: Registry, params: {
    prompt: PromptArgument<I>;
    input: z.infer<I>;
    docs?: DocumentData[];
    model: ModelArgument<CustomOptions>;
    config?: z.infer<CustomOptions>;
}): Promise<GenerateOptions<O, CustomOptions>>;
declare function isExecutablePrompt(obj: any): boolean;

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * An action with a `tool` type.
 */
type ToolAction<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny> = Action<I, O> & {
    __action: {
        metadata: {
            type: 'tool';
        };
    };
};
/**
 * Configuration for a tool.
 */
interface ToolConfig<I extends z.ZodTypeAny, O extends z.ZodTypeAny> {
    /** Unique name of the tool to use as a key in the registry. */
    name: string;
    /** Description of the tool. This is passed to the model to help understand what the tool is used for. */
    description: string;
    /** Input Zod schema. Mutually exclusive with `inputJsonSchema`. */
    inputSchema?: I;
    /** Input JSON schema. Mutually exclusive with `inputSchema`. */
    inputJsonSchema?: JSONSchema7;
    /** Output Zod schema. Mutually exclusive with `outputJsonSchema`. */
    outputSchema?: O;
    /** Output JSON schema. Mutually exclusive with `outputSchema`. */
    outputJsonSchema?: JSONSchema7;
    /** Metadata to be passed to the tool. */
    metadata?: Record<string, any>;
}
/**
 * A reference to a tool in the form of a name, definition, or the action itself.
 */
type ToolArgument<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny> = string | ToolAction<I, O> | Action<I, O> | ToolDefinition | ExecutablePrompt<any, any, any>;
/**
 * Converts an action to a tool action by setting the appropriate metadata.
 */
declare function asTool<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(action: Action<I, O>): ToolAction<I, O>;
/**
 * Resolves a mix of various formats of tool references to a list of tool actions by looking them up in the registry.
 */
declare function resolveTools<O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = z.ZodTypeAny>(registry: Registry, tools?: ToolArgument[]): Promise<ToolAction[]>;
declare function lookupToolByName(registry: Registry, name: string): Promise<ToolAction>;
/**
 * Converts a tool action to a definition of the tool to be passed to a model.
 */
declare function toToolDefinition(tool: Action<z.ZodTypeAny, z.ZodTypeAny>): ToolDefinition;
/**
 * Defines a tool.
 *
 * A tool is an action that can be passed to a model to be called automatically if it so chooses.
 */
declare function defineTool<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(registry: Registry, config: ToolConfig<I, O>, fn: (input: z.infer<I>) => Promise<z.infer<O>>): ToolAction<I, O>;

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

interface OutputOptions<O extends z.ZodTypeAny = z.ZodTypeAny> {
    format?: string;
    contentType?: string;
    instructions?: boolean | string;
    schema?: O;
    jsonSchema?: any;
}
interface GenerateOptions<O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = z.ZodTypeAny> {
    /** A model name (e.g. `vertexai/gemini-1.0-pro`) or reference. */
    model?: ModelArgument<CustomOptions>;
    /** The system prompt to be included in the generate request. Can be a string for a simple text prompt or one or more parts for multi-modal prompts (subject to model support). */
    system?: string | Part | Part[];
    /** The prompt for which to generate a response. Can be a string for a simple text prompt or one or more parts for multi-modal prompts. */
    prompt?: string | Part | Part[];
    /** Retrieved documents to be used as context for this generation. */
    docs?: DocumentData[];
    /** Conversation messages (history) for multi-turn prompting when supported by the underlying model. */
    messages?: (MessageData & {
        content: Part[] | string | (string | Part)[];
    })[];
    /** List of registered tool names or actions to treat as a tool for this generation if supported by the underlying model. */
    tools?: ToolArgument[];
    /** Configuration for the generation request. */
    config?: z.infer<CustomOptions>;
    /** Configuration for the desired output of the request. Defaults to the model's default output if unspecified. */
    output?: OutputOptions<O>;
    /** When true, return tool calls for manual processing instead of automatically resolving them. */
    returnToolRequests?: boolean;
    /** When provided, models supporting streaming will call the provided callback with chunks as generation progresses. */
    streamingCallback?: StreamingCallback<GenerateResponseChunk>;
    /** Middleware to be used with this model call. */
    use?: ModelMiddleware[];
}
declare function toGenerateRequest(registry: Registry, options: GenerateOptions): Promise<GenerateRequest>;
declare class GenerationResponseError extends GenkitError {
    detail: {
        response: GenerateResponse;
        [otherDetails: string]: any;
    };
    constructor(response: GenerateResponse<any>, message: string, status?: GenkitError['status'], detail?: Record<string, any>);
}
/** A GenerationBlockedError is thrown when a generation is blocked. */
declare class GenerationBlockedError extends GenerationResponseError {
}
/**
 * Generate calls a generative model based on the provided prompt and configuration. If
 * `history` is provided, the generation will include a conversation history in its
 * request. If `tools` are provided, the generate method will automatically resolve
 * tool calls returned from the model unless `returnToolRequests` is set to `true`.
 *
 * See `GenerateOptions` for detailed information about available options.
 *
 * @param options The options for this generation request.
 * @returns The generated response based on the provided parameters.
 */
declare function generate<O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema>(registry: Registry, options: GenerateOptions<O, CustomOptions> | PromiseLike<GenerateOptions<O, CustomOptions>>): Promise<GenerateResponse<z.infer<O>>>;
type GenerateStreamOptions<O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema> = Omit<GenerateOptions<O, CustomOptions>, 'streamingCallback'>;
interface GenerateStreamResponse<O extends z.ZodTypeAny = z.ZodTypeAny> {
    get stream(): AsyncIterable<GenerateResponseChunk>;
    get response(): Promise<GenerateResponse<O>>;
}
declare function generateStream<O extends z.ZodTypeAny = z.ZodTypeAny, CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema>(registry: Registry, options: GenerateOptions<O, CustomOptions> | PromiseLike<GenerateOptions<O, CustomOptions>>): Promise<GenerateStreamResponse<O>>;
declare function tagAsPreamble(msgs?: MessageData[]): MessageData[] | undefined;

export { type ExecutablePrompt as E, GenerationBlockedError as G, type OutputOptions as O, type PromptAction as P, type ToolAction as T, GenerationResponseError as a, generateStream as b, toGenerateRequest as c, type GenerateOptions as d, type GenerateStreamOptions as e, type GenerateStreamResponse as f, generate as g, definePrompt as h, isExecutablePrompt as i, type PromptConfig as j, type PromptFn as k, type PromptGenerateOptions as l, asTool as m, defineTool as n, type ToolArgument as o, type ToolConfig as p, isPrompt as q, renderPrompt as r, type PromptArgument as s, tagAsPreamble as t, resolveTools as u, lookupToolByName as v, toToolDefinition as w };
