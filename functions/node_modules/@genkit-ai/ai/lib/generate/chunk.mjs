import "../chunk-7LUMLJGI.mjs";
import { GenkitError } from "@genkit-ai/core";
import { extractJson } from "../extract.js";
class GenerateResponseChunk {
  constructor(data, options) {
    this.content = data.content || [];
    this.custom = data.custom;
    this.previousChunks = (options == null ? void 0 : options.previousChunks) ? [...options.previousChunks] : void 0;
    this.index = options == null ? void 0 : options.index;
    this.role = options == null ? void 0 : options.role;
    this.parser = options == null ? void 0 : options.parser;
  }
  /**
   * Concatenates all `text` parts present in the chunk with no delimiter.
   * @returns A string of all concatenated text parts.
   */
  get text() {
    return this.content.map((part) => part.text || "").join("");
  }
  /**
   * Concatenates all `text` parts of all chunks from the response thus far.
   * @returns A string of all concatenated chunk text content.
   */
  get accumulatedText() {
    return this.previousText + this.text;
  }
  /**
   * Concatenates all `text` parts of all preceding chunks.
   */
  get previousText() {
    var _a;
    if (!this.previousChunks)
      throw new GenkitError({
        status: "FAILED_PRECONDITION",
        message: "Cannot compose accumulated text without previous chunks."
      });
    return (_a = this.previousChunks) == null ? void 0 : _a.map((c) => c.content.map((p) => p.text || "").join("")).join("");
  }
  /**
   * Returns the first media part detected in the chunk. Useful for extracting
   * (for example) an image from a generation expected to create one.
   * @returns The first detected `media` part in the chunk.
   */
  get media() {
    var _a;
    return ((_a = this.content.find((part) => part.media)) == null ? void 0 : _a.media) || null;
  }
  /**
   * Returns the first detected `data` part of a chunk.
   * @returns The first `data` part detected in the chunk (if any).
   */
  get data() {
    var _a;
    return (_a = this.content.find((part) => part.data)) == null ? void 0 : _a.data;
  }
  /**
   * Returns all tool request found in this chunk.
   * @returns Array of all tool request found in this chunk.
   */
  get toolRequests() {
    return this.content.filter(
      (part) => !!part.toolRequest
    );
  }
  /**
   * Parses the chunk into the desired output format using the parser associated
   * with the generate request, or falls back to naive JSON parsing otherwise.
   */
  get output() {
    if (this.parser) return this.parser(this);
    return this.data || extractJson(this.accumulatedText);
  }
  toJSON() {
    return { content: this.content, custom: this.custom };
  }
}
export {
  GenerateResponseChunk
};
//# sourceMappingURL=chunk.mjs.map