{"version":3,"sources":["../../src/generate/action.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  GenkitError,\n  getStreamingCallback,\n  runWithStreamingCallback,\n  z,\n} from '@genkit-ai/core';\nimport { logger } from '@genkit-ai/core/logging';\nimport { Registry } from '@genkit-ai/core/registry';\nimport { toJsonSchema } from '@genkit-ai/core/schema';\nimport { SPAN_TYPE_ATTR, runInNewSpan } from '@genkit-ai/core/tracing';\nimport * as clc from 'colorette';\nimport { DocumentDataSchema } from '../document.js';\nimport { resolveFormat } from '../formats/index.js';\nimport { Formatter } from '../formats/types.js';\nimport {\n  GenerateResponse,\n  GenerateResponseChunk,\n  tagAsPreamble,\n} from '../generate.js';\nimport {\n  GenerateRequest,\n  GenerateRequestSchema,\n  GenerateResponseChunkData,\n  GenerateResponseData,\n  MessageData,\n  MessageSchema,\n  ModelMiddleware,\n  Part,\n  Role,\n  ToolDefinitionSchema,\n  ToolResponsePart,\n  resolveModel,\n} from '../model.js';\nimport { ToolAction, resolveTools, toToolDefinition } from '../tool.js';\n\nexport const GenerateUtilParamSchema = z.object({\n  /** A model name (e.g. `vertexai/gemini-1.0-pro`). */\n  model: z.string(),\n  /** Retrieved documents to be used as context for this generation. */\n  docs: z.array(DocumentDataSchema).optional(),\n  /** Conversation history for multi-turn prompting when supported by the underlying model. */\n  messages: z.array(MessageSchema),\n  /** List of registered tool names for this generation if supported by the underlying model. */\n  tools: z.array(z.union([z.string(), ToolDefinitionSchema])).optional(),\n  /** Configuration for the generation request. */\n  config: z.any().optional(),\n  /** Configuration for the desired output of the request. Defaults to the model's default output if unspecified. */\n  output: z\n    .object({\n      format: z.string().optional(),\n      contentType: z.string().optional(),\n      instructions: z.union([z.boolean(), z.string()]).optional(),\n      jsonSchema: z.any().optional(),\n    })\n    .optional(),\n  /** When true, return tool calls for manual processing instead of automatically resolving them. */\n  returnToolRequests: z.boolean().optional(),\n});\n\n/**\n * Encapsulates all generate logic. This is similar to `generateAction` except not an action and can take middleware.\n */\nexport async function generateHelper(\n  registry: Registry,\n  input: z.infer<typeof GenerateUtilParamSchema>,\n  middleware?: ModelMiddleware[]\n): Promise<GenerateResponseData> {\n  // do tracing\n  return await runInNewSpan(\n    {\n      metadata: {\n        name: 'generate',\n      },\n      labels: {\n        [SPAN_TYPE_ATTR]: 'helper',\n      },\n    },\n    async (metadata) => {\n      metadata.name = 'generate';\n      metadata.input = input;\n      const output = await generate(registry, input, middleware);\n      metadata.output = JSON.stringify(output);\n      return output;\n    }\n  );\n}\n\nasync function generate(\n  registry: Registry,\n  rawRequest: z.infer<typeof GenerateUtilParamSchema>,\n  middleware?: ModelMiddleware[]\n): Promise<GenerateResponseData> {\n  const { modelAction: model } = await resolveModel(registry, rawRequest.model);\n  if (model.__action.metadata?.model.stage === 'deprecated') {\n    logger.warn(\n      `${clc.bold(clc.yellow('Warning:'))} ` +\n        `Model '${model.__action.name}' is deprecated and may be removed in a future release.`\n    );\n  }\n\n  const tools = await resolveTools(registry, rawRequest.tools);\n\n  const resolvedFormat = await resolveFormat(registry, rawRequest.output);\n  // Create a lookup of tool names with namespaces stripped to original names\n  const toolMap = tools.reduce<Record<string, ToolAction>>((acc, tool) => {\n    const name = tool.__action.name;\n    const shortName = name.substring(name.lastIndexOf('/') + 1);\n    if (acc[shortName]) {\n      throw new GenkitError({\n        status: 'INVALID_ARGUMENT',\n        message: `Cannot provide two tools with the same name: '${name}' and '${acc[shortName]}'`,\n      });\n    }\n    acc[shortName] = tool;\n    return acc;\n  }, {});\n\n  const request = await actionToGenerateRequest(\n    rawRequest,\n    tools,\n    resolvedFormat\n  );\n\n  const accumulatedChunks: GenerateResponseChunkData[] = [];\n\n  const streamingCallback = getStreamingCallback();\n  const response = await runWithStreamingCallback(\n    streamingCallback\n      ? (chunk: GenerateResponseChunkData) => {\n          // Store accumulated chunk data\n          if (streamingCallback) {\n            streamingCallback!(\n              new GenerateResponseChunk(chunk, {\n                index: 0,\n                role: 'model',\n                previousChunks: accumulatedChunks,\n                parser: resolvedFormat?.handler(request.output?.schema)\n                  .parseChunk,\n              })\n            );\n          }\n          accumulatedChunks.push(chunk);\n        }\n      : undefined,\n    async () => {\n      const dispatch = async (\n        index: number,\n        req: z.infer<typeof GenerateRequestSchema>\n      ) => {\n        if (!middleware || index === middleware.length) {\n          // end of the chain, call the original model action\n          return await model(req);\n        }\n\n        const currentMiddleware = middleware[index];\n        return currentMiddleware(req, async (modifiedReq) =>\n          dispatch(index + 1, modifiedReq || req)\n        );\n      };\n\n      return new GenerateResponse(await dispatch(0, request), {\n        request,\n        parser: resolvedFormat?.handler(request.output?.schema).parseMessage,\n      });\n    }\n  );\n\n  // Throw an error if the response is not usable.\n  response.assertValid(request);\n  const message = response.message!; // would have thrown if no message\n\n  const toolCalls = message.content.filter((part) => !!part.toolRequest);\n  if (rawRequest.returnToolRequests || toolCalls.length === 0) {\n    return response.toJSON();\n  }\n  const toolResponses: ToolResponsePart[] = [];\n  let messages: MessageData[] = [...request.messages, message];\n  let newTools = rawRequest.tools;\n  for (const part of toolCalls) {\n    if (!part.toolRequest) {\n      throw Error(\n        'Tool request expected but not provided in tool request part'\n      );\n    }\n    const tool = toolMap[part.toolRequest?.name];\n    if (!tool) {\n      throw Error(`Tool ${part.toolRequest?.name} not found`);\n    }\n    if ((tool.__action.metadata.type as string) === 'prompt') {\n      const newPreamble = await tool(part.toolRequest?.input);\n      toolResponses.push({\n        toolResponse: {\n          name: part.toolRequest.name,\n          ref: part.toolRequest.ref,\n          output: `transferred to ${part.toolRequest.name}`,\n        },\n      });\n      // swap out the preamble\n      messages = [\n        ...tagAsPreamble(newPreamble.messages)!,\n        ...messages.filter((m) => !m?.metadata?.preamble),\n      ];\n      newTools = newPreamble.tools;\n    } else {\n      toolResponses.push({\n        toolResponse: {\n          name: part.toolRequest.name,\n          ref: part.toolRequest.ref,\n          output: await tool(part.toolRequest?.input),\n        },\n      });\n    }\n  }\n  const nextRequest = {\n    ...rawRequest,\n    messages: [\n      ...messages,\n      {\n        role: 'tool',\n        content: toolResponses,\n      },\n    ] as MessageData[],\n    tools: newTools,\n  };\n  return await generateHelper(registry, nextRequest, middleware);\n}\n\nasync function actionToGenerateRequest(\n  options: z.infer<typeof GenerateUtilParamSchema>,\n  resolvedTools?: ToolAction[],\n  resolvedFormat?: Formatter\n): Promise<GenerateRequest> {\n  const out = {\n    messages: options.messages,\n    config: options.config,\n    docs: options.docs,\n    tools: resolvedTools?.map(toToolDefinition) || [],\n    output: {\n      ...(resolvedFormat?.config || {}),\n      schema: toJsonSchema({\n        jsonSchema: options.output?.jsonSchema,\n      }),\n    },\n  };\n  if (!out.output.schema) delete out.output.schema;\n  return out;\n}\n\nexport function inferRoleFromParts(parts: Part[]): Role {\n  const uniqueRoles = new Set<Role>();\n  for (const part of parts) {\n    const role = getRoleFromPart(part);\n    uniqueRoles.add(role);\n    if (uniqueRoles.size > 1) {\n      throw new Error('Contents contain mixed roles');\n    }\n  }\n  return Array.from(uniqueRoles)[0];\n}\n\nfunction getRoleFromPart(part: Part): Role {\n  if (part.toolRequest !== undefined) return 'model';\n  if (part.toolResponse !== undefined) return 'tool';\n  if (part.text !== undefined) return 'user';\n  if (part.media !== undefined) return 'user';\n  if (part.data !== undefined) return 'user';\n  throw new Error('No recognized fields in content');\n}\n"],"mappings":"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","names":["_a"]}