import "../chunk-7LUMLJGI.mjs";
import { parseSchema } from "@genkit-ai/core/schema";
import {
  GenerationBlockedError,
  GenerationResponseError
} from "../generate.js";
import { Message } from "../message.js";
class GenerateResponse {
  constructor(response, options) {
    var _a, _b, _c, _d, _e, _f;
    const generatedMessage = response.message || ((_b = (_a = response.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.message);
    if (generatedMessage) {
      this.message = new Message(generatedMessage, {
        parser: options == null ? void 0 : options.parser
      });
    }
    this.finishReason = response.finishReason || ((_d = (_c = response.candidates) == null ? void 0 : _c[0]) == null ? void 0 : _d.finishReason);
    this.finishMessage = response.finishMessage || ((_f = (_e = response.candidates) == null ? void 0 : _e[0]) == null ? void 0 : _f.finishMessage);
    this.usage = response.usage || {};
    this.custom = response.custom || {};
    this.request = options == null ? void 0 : options.request;
  }
  get assertMessage() {
    if (!this.message)
      throw new Error(
        "Operation could not be completed because the response does not contain a generated message."
      );
    return this.message;
  }
  /**
   * Throws an error if the response does not contain valid output.
   */
  assertValid(request) {
    var _a, _b, _c, _d, _e, _f;
    if (this.finishReason === "blocked") {
      throw new GenerationBlockedError(
        this,
        `Generation blocked${this.finishMessage ? `: ${this.finishMessage}` : "."}`
      );
    }
    if (!this.message) {
      throw new GenerationResponseError(
        this,
        `Model did not generate a message. Finish reason: '${this.finishReason}': ${this.finishMessage}`
      );
    }
    if (((_a = request == null ? void 0 : request.output) == null ? void 0 : _a.schema) || ((_c = (_b = this.request) == null ? void 0 : _b.output) == null ? void 0 : _c.schema)) {
      const o = this.output;
      parseSchema(o, {
        jsonSchema: ((_d = request == null ? void 0 : request.output) == null ? void 0 : _d.schema) || ((_f = (_e = this.request) == null ? void 0 : _e.output) == null ? void 0 : _f.schema)
      });
    }
  }
  isValid(request) {
    try {
      this.assertValid(request);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * If the selected candidate's message contains a `data` part, it is returned. Otherwise,
   * the `output()` method extracts the first valid JSON object or array from the text
   * contained in the selected candidate's message and returns it.
   *
   * @param index The candidate index from which to extract output. If not provided, finds first candidate that conforms to output schema.
   * @returns The structured output contained in the selected candidate.
   */
  get output() {
    var _a;
    return ((_a = this.message) == null ? void 0 : _a.output) || null;
  }
  /**
   * Concatenates all `text` parts present in the candidate's message with no delimiter.
   * @param index The candidate index from which to extract text, defaults to first candidate.
   * @returns A string of all concatenated text parts.
   */
  get text() {
    var _a;
    return ((_a = this.message) == null ? void 0 : _a.text) || "";
  }
  /**
   * Returns the first detected media part in the selected candidate's message. Useful for
   * extracting (for example) an image from a generation expected to create one.
   * @param index The candidate index from which to extract media, defaults to first candidate.
   * @returns The first detected `media` part in the candidate.
   */
  get media() {
    var _a;
    return ((_a = this.message) == null ? void 0 : _a.media) || null;
  }
  /**
   * Returns the first detected `data` part of the selected candidate's message.
   * @param index The candidate index from which to extract data, defaults to first candidate.
   * @returns The first `data` part detected in the candidate (if any).
   */
  get data() {
    var _a;
    return ((_a = this.message) == null ? void 0 : _a.data) || null;
  }
  /**
   * Returns all tool request found in the candidate.
   * @param index The candidate index from which to extract tool requests, defaults to first candidate.
   * @returns Array of all tool request found in the candidate.
   */
  get toolRequests() {
    var _a;
    return ((_a = this.message) == null ? void 0 : _a.toolRequests) || [];
  }
  /**
   * Appends the message generated by the selected candidate to the messages already
   * present in the generation request. The result of this method can be safely
   * serialized to JSON for persistence in a database.
   * @param index The candidate index to utilize during conversion, defaults to first candidate.
   * @returns A serializable list of messages compatible with `generate({history})`.
   */
  get messages() {
    var _a;
    if (!this.request)
      throw new Error(
        "Can't construct history for response without request reference."
      );
    if (!this.message)
      throw new Error(
        "Can't construct history for response without generated message."
      );
    return [...(_a = this.request) == null ? void 0 : _a.messages, this.message.toJSON()];
  }
  get raw() {
    var _a;
    return (_a = this.raw) != null ? _a : this.custom;
  }
  toJSON() {
    var _a, _b, _c;
    const out = {
      message: (_a = this.message) == null ? void 0 : _a.toJSON(),
      finishReason: this.finishReason,
      finishMessage: this.finishMessage,
      usage: this.usage,
      custom: ((_c = (_b = this.custom).toJSON) == null ? void 0 : _c.call(_b)) || this.custom,
      request: this.request
    };
    if (!out.finishMessage) delete out.finishMessage;
    if (!out.request) delete out.request;
    return out;
  }
}
export {
  GenerateResponse
};
//# sourceMappingURL=response.mjs.map