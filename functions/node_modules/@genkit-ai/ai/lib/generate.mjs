import {
  __async,
  __asyncGenerator,
  __await,
  __spreadProps,
  __spreadValues
} from "./chunk-7LUMLJGI.mjs";
import {
  GenkitError,
  runWithStreamingCallback
} from "@genkit-ai/core";
import { toJsonSchema } from "@genkit-ai/core/schema";
import {
  injectInstructions,
  resolveFormat,
  resolveInstructions
} from "./formats/index.js";
import { generateHelper } from "./generate/action.js";
import { GenerateResponseChunk } from "./generate/chunk.js";
import { GenerateResponse } from "./generate/response.js";
import { Message } from "./message.js";
import {
  resolveModel
} from "./model.js";
import { resolveTools, toToolDefinition } from "./tool.js";
function toGenerateRequest(registry, options) {
  return __async(this, null, function* () {
    var _a, _b, _c;
    const messages = [];
    if (options.system) {
      messages.push({
        role: "system",
        content: Message.parseContent(options.system)
      });
    }
    if (options.messages) {
      messages.push(...options.messages.map((m) => Message.parseData(m)));
    }
    if (options.prompt) {
      messages.push({
        role: "user",
        content: Message.parseContent(options.prompt)
      });
    }
    if (messages.length === 0) {
      throw new GenkitError({
        status: "INVALID_ARGUMENT",
        message: "at least one message is required in generate request"
      });
    }
    let tools;
    if (options.tools) {
      tools = yield resolveTools(registry, options.tools);
    }
    const resolvedSchema = toJsonSchema({
      schema: (_a = options.output) == null ? void 0 : _a.schema,
      jsonSchema: (_b = options.output) == null ? void 0 : _b.jsonSchema
    });
    const resolvedFormat = yield resolveFormat(registry, options.output);
    const instructions = resolveInstructions(
      resolvedFormat,
      resolvedSchema,
      (_c = options == null ? void 0 : options.output) == null ? void 0 : _c.instructions
    );
    const out = {
      messages: injectInstructions(messages, instructions),
      config: options.config,
      docs: options.docs,
      tools: (tools == null ? void 0 : tools.map(toToolDefinition)) || [],
      output: __spreadProps(__spreadValues({}, (resolvedFormat == null ? void 0 : resolvedFormat.config) || {}), {
        schema: resolvedSchema
      })
    };
    if (!out.output.schema) delete out.output.schema;
    return out;
  });
}
class GenerationResponseError extends GenkitError {
  constructor(response, message, status, detail) {
    super({
      status: status || "FAILED_PRECONDITION",
      message
    });
    this.detail = __spreadValues({ response }, detail);
  }
}
function toolsToActionRefs(registry, toolOpt) {
  return __async(this, null, function* () {
    var _a;
    if (!toolOpt) return;
    let tools = [];
    for (const t of toolOpt) {
      if (typeof t === "string") {
        tools.push(yield resolveFullToolName(registry, t));
      } else if (t.__action) {
        tools.push(
          `/${(_a = t.__action.metadata) == null ? void 0 : _a.type}/${t.__action.name}`
        );
      } else if (typeof t.asTool === "function") {
        const promptToolAction = yield t.asTool();
        tools.push(`/prompt/${promptToolAction.__action.name}`);
      } else if (t.name) {
        tools.push(yield resolveFullToolName(registry, t.name));
      } else {
        throw new Error(`Unable to determine type of tool: ${JSON.stringify(t)}`);
      }
    }
    return tools;
  });
}
function messagesFromOptions(options) {
  const messages = [];
  if (options.system) {
    messages.push({
      role: "system",
      content: Message.parseContent(options.system)
    });
  }
  if (options.messages) {
    messages.push(...options.messages);
  }
  if (options.prompt) {
    messages.push({
      role: "user",
      content: Message.parseContent(options.prompt)
    });
  }
  if (messages.length === 0) {
    throw new GenkitError({
      status: "INVALID_ARGUMENT",
      message: "at least one message is required in generate request"
    });
  }
  return messages;
}
class GenerationBlockedError extends GenerationResponseError {
}
function generate(registry, options) {
  return __async(this, null, function* () {
    var _a, _b, _c, _d, _e;
    const resolvedOptions = __spreadValues({}, yield Promise.resolve(options));
    const resolvedModel = yield resolveModel(registry, resolvedOptions.model);
    const tools = yield toolsToActionRefs(registry, resolvedOptions.tools);
    const messages = messagesFromOptions(resolvedOptions);
    const resolvedSchema = toJsonSchema({
      schema: (_a = resolvedOptions.output) == null ? void 0 : _a.schema,
      jsonSchema: (_b = resolvedOptions.output) == null ? void 0 : _b.jsonSchema
    });
    if (((_c = resolvedOptions.output) == null ? void 0 : _c.schema) && !((_d = resolvedOptions.output) == null ? void 0 : _d.format)) {
      resolvedOptions.output.format = "json";
    }
    const resolvedFormat = yield resolveFormat(registry, resolvedOptions.output);
    const instructions = resolveInstructions(
      resolvedFormat,
      resolvedSchema,
      (_e = resolvedOptions == null ? void 0 : resolvedOptions.output) == null ? void 0 : _e.instructions
    );
    const params = {
      model: resolvedModel.modelAction.__action.name,
      docs: resolvedOptions.docs,
      messages: injectInstructions(messages, instructions),
      tools,
      config: __spreadValues(__spreadValues({
        version: resolvedModel.version
      }, stripUndefinedOptions(resolvedModel.config)), stripUndefinedOptions(resolvedOptions.config)),
      output: resolvedOptions.output && {
        format: resolvedOptions.output.format,
        jsonSchema: resolvedSchema
      },
      returnToolRequests: resolvedOptions.returnToolRequests
    };
    return yield runWithStreamingCallback(
      resolvedOptions.streamingCallback,
      () => __async(this, null, function* () {
        var _a2, _b2;
        const response = yield generateHelper(
          registry,
          params,
          resolvedOptions.use
        );
        const request = yield toGenerateRequest(registry, __spreadProps(__spreadValues({}, resolvedOptions), {
          tools
        }));
        return new GenerateResponse(response, {
          request: (_a2 = response.request) != null ? _a2 : request,
          parser: resolvedFormat == null ? void 0 : resolvedFormat.handler((_b2 = request.output) == null ? void 0 : _b2.schema).parseMessage
        });
      })
    );
  });
}
function stripUndefinedOptions(input) {
  if (!input) return input;
  const copy = __spreadValues({}, input);
  Object.keys(input).forEach((key) => {
    if (copy[key] === void 0) {
      delete copy[key];
    }
  });
  return copy;
}
function resolveFullToolName(registry, name) {
  return __async(this, null, function* () {
    if (yield registry.lookupAction(`/tool/${name}`)) {
      return `/tool/${name}`;
    } else if (yield registry.lookupAction(`/prompt/${name}`)) {
      return `/prompt/${name}`;
    } else {
      throw new Error(`Unable to determine type of of tool: ${name}`);
    }
  });
}
function createPromise() {
  let resolve, reject;
  let promise = new Promise((res, rej) => [resolve, reject] = [res, rej]);
  return { resolve, reject, promise };
}
function generateStream(registry, options) {
  return __async(this, null, function* () {
    let firstChunkSent = false;
    return new Promise(
      (initialResolve, initialReject) => {
        const {
          resolve: finalResolve,
          reject: finalReject,
          promise: finalPromise
        } = createPromise();
        let provideNextChunk, nextChunk;
        ({ resolve: provideNextChunk, promise: nextChunk } = createPromise());
        function chunkStream() {
          return __asyncGenerator(this, null, function* () {
            while (true) {
              const next = yield new __await(nextChunk);
              if (!next) break;
              yield next;
            }
          });
        }
        try {
          generate(registry, __spreadProps(__spreadValues({}, options), {
            streamingCallback: (chunk) => {
              firstChunkSent = true;
              provideNextChunk(chunk);
              ({ resolve: provideNextChunk, promise: nextChunk } = createPromise());
            }
          })).then((result) => {
            provideNextChunk(null);
            finalResolve(result);
          }).catch((e) => {
            if (!firstChunkSent) {
              initialReject(e);
              return;
            }
            provideNextChunk(null);
            finalReject(e);
          });
        } catch (e) {
          if (!firstChunkSent) {
            initialReject(e);
            return;
          }
          provideNextChunk(null);
          finalReject(e);
        }
        initialResolve({
          get response() {
            return finalPromise;
          },
          get stream() {
            return chunkStream();
          }
        });
      }
    );
  });
}
function tagAsPreamble(msgs) {
  if (!msgs) {
    return void 0;
  }
  return msgs.map((m) => __spreadProps(__spreadValues({}, m), {
    metadata: __spreadProps(__spreadValues({}, m.metadata), {
      preamble: true
    })
  }));
}
export {
  GenerateResponse,
  GenerateResponseChunk,
  GenerationBlockedError,
  GenerationResponseError,
  generate,
  generateStream,
  tagAsPreamble,
  toGenerateRequest
};
//# sourceMappingURL=generate.mjs.map