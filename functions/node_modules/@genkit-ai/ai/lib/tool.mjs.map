{"version":3,"sources":["../src/tool.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Action, defineAction, JSONSchema7, z } from '@genkit-ai/core';\nimport { Registry } from '@genkit-ai/core/registry';\nimport { toJsonSchema } from '@genkit-ai/core/schema';\nimport { setCustomMetadataAttributes } from '@genkit-ai/core/tracing';\nimport { ToolDefinition } from './model.js';\nimport { ExecutablePrompt } from './prompt.js';\n\n/**\n * An action with a `tool` type.\n */\nexport type ToolAction<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n> = Action<I, O> & {\n  __action: {\n    metadata: {\n      type: 'tool';\n    };\n  };\n};\n\n/**\n * Configuration for a tool.\n */\nexport interface ToolConfig<I extends z.ZodTypeAny, O extends z.ZodTypeAny> {\n  /** Unique name of the tool to use as a key in the registry. */\n  name: string;\n  /** Description of the tool. This is passed to the model to help understand what the tool is used for. */\n  description: string;\n  /** Input Zod schema. Mutually exclusive with `inputJsonSchema`. */\n  inputSchema?: I;\n  /** Input JSON schema. Mutually exclusive with `inputSchema`. */\n  inputJsonSchema?: JSONSchema7;\n  /** Output Zod schema. Mutually exclusive with `outputJsonSchema`. */\n  outputSchema?: O;\n  /** Output JSON schema. Mutually exclusive with `outputSchema`. */\n  outputJsonSchema?: JSONSchema7;\n  /** Metadata to be passed to the tool. */\n  metadata?: Record<string, any>;\n}\n\n/**\n * A reference to a tool in the form of a name, definition, or the action itself.\n */\nexport type ToolArgument<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n> =\n  | string\n  | ToolAction<I, O>\n  | Action<I, O>\n  | ToolDefinition\n  | ExecutablePrompt<any, any, any>;\n\n/**\n * Converts an action to a tool action by setting the appropriate metadata.\n */\nexport function asTool<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(\n  action: Action<I, O>\n): ToolAction<I, O> {\n  if (action.__action?.metadata?.type === 'tool') {\n    return action as ToolAction<I, O>;\n  }\n\n  const fn = ((input) => {\n    setCustomMetadataAttributes({ subtype: 'tool' });\n    return action(input);\n  }) as ToolAction<I, O>;\n  fn.__action = {\n    ...action.__action,\n    metadata: { ...action.__action.metadata, type: 'tool' },\n  };\n  return fn;\n}\n\n/**\n * Resolves a mix of various formats of tool references to a list of tool actions by looking them up in the registry.\n */\nexport async function resolveTools<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  CustomOptions extends z.ZodTypeAny = z.ZodTypeAny,\n>(registry: Registry, tools?: ToolArgument[]): Promise<ToolAction[]> {\n  if (!tools || tools.length === 0) {\n    return [];\n  }\n\n  return await Promise.all(\n    tools.map(async (ref): Promise<ToolAction> => {\n      if (typeof ref === 'string') {\n        return await lookupToolByName(registry, ref);\n      } else if ((ref as Action).__action) {\n        return asTool(ref as Action);\n      } else if (typeof (ref as ExecutablePrompt).asTool === 'function') {\n        return await (ref as ExecutablePrompt).asTool();\n      } else if (ref.name) {\n        return await lookupToolByName(\n          registry,\n          (ref as ToolDefinition).metadata?.originalName || ref.name\n        );\n      }\n      throw new Error('Tools must be strings, tool definitions, or actions.');\n    })\n  );\n}\n\nexport async function lookupToolByName(\n  registry: Registry,\n  name: string\n): Promise<ToolAction> {\n  let tool =\n    (await registry.lookupAction(name)) ||\n    (await registry.lookupAction(`/tool/${name}`)) ||\n    (await registry.lookupAction(`/prompt/${name}`));\n  if (!tool) {\n    throw new Error(`Tool ${name} not found`);\n  }\n  return tool as ToolAction;\n}\n\n/**\n * Converts a tool action to a definition of the tool to be passed to a model.\n */\nexport function toToolDefinition(\n  tool: Action<z.ZodTypeAny, z.ZodTypeAny>\n): ToolDefinition {\n  const originalName = tool.__action.name;\n  let name = originalName;\n  if (originalName.includes('/')) {\n    name = originalName.substring(originalName.lastIndexOf('/') + 1);\n  }\n\n  const out: ToolDefinition = {\n    name,\n    description: tool.__action.description || '',\n    outputSchema: toJsonSchema({\n      schema: tool.__action.outputSchema ?? z.void(),\n      jsonSchema: tool.__action.outputJsonSchema,\n    })!,\n    inputSchema: toJsonSchema({\n      schema: tool.__action.inputSchema ?? z.void(),\n      jsonSchema: tool.__action.inputJsonSchema,\n    })!,\n  };\n\n  if (originalName !== name) {\n    out.metadata = { originalName };\n  }\n\n  return out;\n}\n\n/**\n * Defines a tool.\n *\n * A tool is an action that can be passed to a model to be called automatically if it so chooses.\n */\nexport function defineTool<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(\n  registry: Registry,\n  config: ToolConfig<I, O>,\n  fn: (input: z.infer<I>) => Promise<z.infer<O>>\n): ToolAction<I, O> {\n  const a = defineAction(\n    registry,\n    {\n      ...config,\n      actionType: 'tool',\n      metadata: { ...(config.metadata || {}), type: 'tool' },\n    },\n    (i) => fn(i)\n  );\n  return a as ToolAction<I, O>;\n}\n"],"mappings":";;;;;AAgBA,SAAiB,cAA2B,SAAS;AAErD,SAAS,oBAAoB;AAC7B,SAAS,mCAAmC;AAsDrC,SAAS,OACd,QACkB;AA3EpB;AA4EE,QAAI,kBAAO,aAAP,mBAAiB,aAAjB,mBAA2B,UAAS,QAAQ;AAC9C,WAAO;AAAA,EACT;AAEA,QAAM,KAAM,CAAC,UAAU;AACrB,gCAA4B,EAAE,SAAS,OAAO,CAAC;AAC/C,WAAO,OAAO,KAAK;AAAA,EACrB;AACA,KAAG,WAAW,iCACT,OAAO,WADE;AAAA,IAEZ,UAAU,iCAAK,OAAO,SAAS,WAArB,EAA+B,MAAM,OAAO;AAAA,EACxD;AACA,SAAO;AACT;AAKA,SAAsB,aAGpB,UAAoB,OAA+C;AAAA;AACnE,QAAI,CAAC,SAAS,MAAM,WAAW,GAAG;AAChC,aAAO,CAAC;AAAA,IACV;AAEA,WAAO,MAAM,QAAQ;AAAA,MACnB,MAAM,IAAI,CAAO,QAA6B;AAvGlD;AAwGM,YAAI,OAAO,QAAQ,UAAU;AAC3B,iBAAO,MAAM,iBAAiB,UAAU,GAAG;AAAA,QAC7C,WAAY,IAAe,UAAU;AACnC,iBAAO,OAAO,GAAa;AAAA,QAC7B,WAAW,OAAQ,IAAyB,WAAW,YAAY;AACjE,iBAAO,MAAO,IAAyB,OAAO;AAAA,QAChD,WAAW,IAAI,MAAM;AACnB,iBAAO,MAAM;AAAA,YACX;AAAA,cACC,SAAuB,aAAvB,mBAAiC,iBAAgB,IAAI;AAAA,UACxD;AAAA,QACF;AACA,cAAM,IAAI,MAAM,sDAAsD;AAAA,MACxE,EAAC;AAAA,IACH;AAAA,EACF;AAAA;AAEA,SAAsB,iBACpB,UACA,MACqB;AAAA;AACrB,QAAI,QACD,MAAM,SAAS,aAAa,IAAI,OAChC,MAAM,SAAS,aAAa,SAAS,IAAI,EAAE,OAC3C,MAAM,SAAS,aAAa,WAAW,IAAI,EAAE;AAChD,QAAI,CAAC,MAAM;AACT,YAAM,IAAI,MAAM,QAAQ,IAAI,YAAY;AAAA,IAC1C;AACA,WAAO;AAAA,EACT;AAAA;AAKO,SAAS,iBACd,MACgB;AA5IlB;AA6IE,QAAM,eAAe,KAAK,SAAS;AACnC,MAAI,OAAO;AACX,MAAI,aAAa,SAAS,GAAG,GAAG;AAC9B,WAAO,aAAa,UAAU,aAAa,YAAY,GAAG,IAAI,CAAC;AAAA,EACjE;AAEA,QAAM,MAAsB;AAAA,IAC1B;AAAA,IACA,aAAa,KAAK,SAAS,eAAe;AAAA,IAC1C,cAAc,aAAa;AAAA,MACzB,SAAQ,UAAK,SAAS,iBAAd,YAA8B,EAAE,KAAK;AAAA,MAC7C,YAAY,KAAK,SAAS;AAAA,IAC5B,CAAC;AAAA,IACD,aAAa,aAAa;AAAA,MACxB,SAAQ,UAAK,SAAS,gBAAd,YAA6B,EAAE,KAAK;AAAA,MAC5C,YAAY,KAAK,SAAS;AAAA,IAC5B,CAAC;AAAA,EACH;AAEA,MAAI,iBAAiB,MAAM;AACzB,QAAI,WAAW,EAAE,aAAa;AAAA,EAChC;AAEA,SAAO;AACT;AAOO,SAAS,WACd,UACA,QACA,IACkB;AAClB,QAAM,IAAI;AAAA,IACR;AAAA,IACA,iCACK,SADL;AAAA,MAEE,YAAY;AAAA,MACZ,UAAU,iCAAM,OAAO,YAAY,CAAC,IAA1B,EAA8B,MAAM,OAAO;AAAA,IACvD;AAAA,IACA,CAAC,MAAM,GAAG,CAAC;AAAA,EACb;AACA,SAAO;AACT;","names":[]}