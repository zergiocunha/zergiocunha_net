{"version":3,"sources":["../src/generate.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Action,\n  GenkitError,\n  runWithStreamingCallback,\n  StreamingCallback,\n  z,\n} from '@genkit-ai/core';\nimport { Registry } from '@genkit-ai/core/registry';\nimport { toJsonSchema } from '@genkit-ai/core/schema';\nimport { DocumentData } from './document.js';\nimport {\n  injectInstructions,\n  resolveFormat,\n  resolveInstructions,\n} from './formats/index.js';\nimport { generateHelper, GenerateUtilParamSchema } from './generate/action.js';\nimport { GenerateResponseChunk } from './generate/chunk.js';\nimport { GenerateResponse } from './generate/response.js';\nimport { Message } from './message.js';\nimport {\n  GenerateRequest,\n  GenerationCommonConfigSchema,\n  MessageData,\n  ModelArgument,\n  ModelMiddleware,\n  Part,\n  resolveModel,\n} from './model.js';\nimport { ExecutablePrompt } from './prompt.js';\nimport { resolveTools, ToolArgument, toToolDefinition } from './tool.js';\nexport { GenerateResponse, GenerateResponseChunk };\n\nexport interface OutputOptions<O extends z.ZodTypeAny = z.ZodTypeAny> {\n  format?: string;\n  contentType?: string;\n  instructions?: boolean | string;\n  schema?: O;\n  jsonSchema?: any;\n}\n\nexport interface GenerateOptions<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  CustomOptions extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  /** A model name (e.g. `vertexai/gemini-1.0-pro`) or reference. */\n  model?: ModelArgument<CustomOptions>;\n  /** The system prompt to be included in the generate request. Can be a string for a simple text prompt or one or more parts for multi-modal prompts (subject to model support). */\n  system?: string | Part | Part[];\n  /** The prompt for which to generate a response. Can be a string for a simple text prompt or one or more parts for multi-modal prompts. */\n  prompt?: string | Part | Part[];\n  /** Retrieved documents to be used as context for this generation. */\n  docs?: DocumentData[];\n  /** Conversation messages (history) for multi-turn prompting when supported by the underlying model. */\n  messages?: (MessageData & { content: Part[] | string | (string | Part)[] })[];\n  /** List of registered tool names or actions to treat as a tool for this generation if supported by the underlying model. */\n  tools?: ToolArgument[];\n  /** Configuration for the generation request. */\n  config?: z.infer<CustomOptions>;\n  /** Configuration for the desired output of the request. Defaults to the model's default output if unspecified. */\n  output?: OutputOptions<O>;\n  /** When true, return tool calls for manual processing instead of automatically resolving them. */\n  returnToolRequests?: boolean;\n  /** When provided, models supporting streaming will call the provided callback with chunks as generation progresses. */\n  streamingCallback?: StreamingCallback<GenerateResponseChunk>;\n  /** Middleware to be used with this model call. */\n  use?: ModelMiddleware[];\n}\n\nexport async function toGenerateRequest(\n  registry: Registry,\n  options: GenerateOptions\n): Promise<GenerateRequest> {\n  const messages: MessageData[] = [];\n  if (options.system) {\n    messages.push({\n      role: 'system',\n      content: Message.parseContent(options.system),\n    });\n  }\n  if (options.messages) {\n    messages.push(...options.messages.map((m) => Message.parseData(m)));\n  }\n  if (options.prompt) {\n    messages.push({\n      role: 'user',\n      content: Message.parseContent(options.prompt),\n    });\n  }\n  if (messages.length === 0) {\n    throw new GenkitError({\n      status: 'INVALID_ARGUMENT',\n      message: 'at least one message is required in generate request',\n    });\n  }\n  let tools: Action<any, any>[] | undefined;\n  if (options.tools) {\n    tools = await resolveTools(registry, options.tools);\n  }\n\n  const resolvedSchema = toJsonSchema({\n    schema: options.output?.schema,\n    jsonSchema: options.output?.jsonSchema,\n  });\n\n  const resolvedFormat = await resolveFormat(registry, options.output);\n  const instructions = resolveInstructions(\n    resolvedFormat,\n    resolvedSchema,\n    options?.output?.instructions\n  );\n\n  const out = {\n    messages: injectInstructions(messages, instructions),\n    config: options.config,\n    docs: options.docs,\n    tools: tools?.map(toToolDefinition) || [],\n    output: {\n      ...(resolvedFormat?.config || {}),\n      schema: resolvedSchema,\n    },\n  };\n  if (!out.output.schema) delete out.output.schema;\n  return out;\n}\n\nexport class GenerationResponseError extends GenkitError {\n  detail: {\n    response: GenerateResponse;\n    [otherDetails: string]: any;\n  };\n\n  constructor(\n    response: GenerateResponse<any>,\n    message: string,\n    status?: GenkitError['status'],\n    detail?: Record<string, any>\n  ) {\n    super({\n      status: status || 'FAILED_PRECONDITION',\n      message,\n    });\n    this.detail = { response, ...detail };\n  }\n}\n\nasync function toolsToActionRefs(\n  registry: Registry,\n  toolOpt?: ToolArgument[]\n): Promise<string[] | undefined> {\n  if (!toolOpt) return;\n\n  let tools: string[] = [];\n\n  for (const t of toolOpt) {\n    if (typeof t === 'string') {\n      tools.push(await resolveFullToolName(registry, t));\n    } else if ((t as Action).__action) {\n      tools.push(\n        `/${(t as Action).__action.metadata?.type}/${(t as Action).__action.name}`\n      );\n    } else if (typeof (t as ExecutablePrompt).asTool === 'function') {\n      const promptToolAction = await (t as ExecutablePrompt).asTool();\n      tools.push(`/prompt/${promptToolAction.__action.name}`);\n    } else if (t.name) {\n      tools.push(await resolveFullToolName(registry, t.name));\n    } else {\n      throw new Error(`Unable to determine type of tool: ${JSON.stringify(t)}`);\n    }\n  }\n  return tools;\n}\n\nfunction messagesFromOptions(options: GenerateOptions): MessageData[] {\n  const messages: MessageData[] = [];\n  if (options.system) {\n    messages.push({\n      role: 'system',\n      content: Message.parseContent(options.system),\n    });\n  }\n  if (options.messages) {\n    messages.push(...options.messages);\n  }\n  if (options.prompt) {\n    messages.push({\n      role: 'user',\n      content: Message.parseContent(options.prompt),\n    });\n  }\n  if (messages.length === 0) {\n    throw new GenkitError({\n      status: 'INVALID_ARGUMENT',\n      message: 'at least one message is required in generate request',\n    });\n  }\n  return messages;\n}\n\n/** A GenerationBlockedError is thrown when a generation is blocked. */\nexport class GenerationBlockedError extends GenerationResponseError {}\n\n/**\n * Generate calls a generative model based on the provided prompt and configuration. If\n * `history` is provided, the generation will include a conversation history in its\n * request. If `tools` are provided, the generate method will automatically resolve\n * tool calls returned from the model unless `returnToolRequests` is set to `true`.\n *\n * See `GenerateOptions` for detailed information about available options.\n *\n * @param options The options for this generation request.\n * @returns The generated response based on the provided parameters.\n */\nexport async function generate<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema,\n>(\n  registry: Registry,\n  options:\n    | GenerateOptions<O, CustomOptions>\n    | PromiseLike<GenerateOptions<O, CustomOptions>>\n): Promise<GenerateResponse<z.infer<O>>> {\n  const resolvedOptions: GenerateOptions<O, CustomOptions> = {\n    ...(await Promise.resolve(options)),\n  };\n  const resolvedModel = await resolveModel(registry, resolvedOptions.model);\n\n  const tools = await toolsToActionRefs(registry, resolvedOptions.tools);\n\n  const messages: MessageData[] = messagesFromOptions(resolvedOptions);\n\n  const resolvedSchema = toJsonSchema({\n    schema: resolvedOptions.output?.schema,\n    jsonSchema: resolvedOptions.output?.jsonSchema,\n  });\n\n  // If is schema is set but format is not explicitly set, default to `json` format.\n  if (resolvedOptions.output?.schema && !resolvedOptions.output?.format) {\n    resolvedOptions.output.format = 'json';\n  }\n  const resolvedFormat = await resolveFormat(registry, resolvedOptions.output);\n  const instructions = resolveInstructions(\n    resolvedFormat,\n    resolvedSchema,\n    resolvedOptions?.output?.instructions\n  );\n\n  const params: z.infer<typeof GenerateUtilParamSchema> = {\n    model: resolvedModel.modelAction.__action.name,\n    docs: resolvedOptions.docs,\n    messages: injectInstructions(messages, instructions),\n    tools,\n    config: {\n      version: resolvedModel.version,\n      ...stripUndefinedOptions(resolvedModel.config),\n      ...stripUndefinedOptions(resolvedOptions.config),\n    },\n    output: resolvedOptions.output && {\n      format: resolvedOptions.output.format,\n      jsonSchema: resolvedSchema,\n    },\n    returnToolRequests: resolvedOptions.returnToolRequests,\n  };\n\n  return await runWithStreamingCallback(\n    resolvedOptions.streamingCallback,\n    async () => {\n      const response = await generateHelper(\n        registry,\n        params,\n        resolvedOptions.use\n      );\n      const request = await toGenerateRequest(registry, {\n        ...resolvedOptions,\n        tools,\n      });\n      return new GenerateResponse<O>(response, {\n        request: response.request ?? request,\n        parser: resolvedFormat?.handler(request.output?.schema).parseMessage,\n      });\n    }\n  );\n}\n\nfunction stripUndefinedOptions(input?: any): any {\n  if (!input) return input;\n  const copy = { ...input };\n  Object.keys(input).forEach((key) => {\n    if (copy[key] === undefined) {\n      delete copy[key];\n    }\n  });\n  return copy;\n}\n\nasync function resolveFullToolName(\n  registry: Registry,\n  name: string\n): Promise<string> {\n  if (await registry.lookupAction(`/tool/${name}`)) {\n    return `/tool/${name}`;\n  } else if (await registry.lookupAction(`/prompt/${name}`)) {\n    return `/prompt/${name}`;\n  } else {\n    throw new Error(`Unable to determine type of of tool: ${name}`);\n  }\n}\n\nexport type GenerateStreamOptions<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema,\n> = Omit<GenerateOptions<O, CustomOptions>, 'streamingCallback'>;\n\nexport interface GenerateStreamResponse<O extends z.ZodTypeAny = z.ZodTypeAny> {\n  get stream(): AsyncIterable<GenerateResponseChunk>;\n  get response(): Promise<GenerateResponse<O>>;\n}\n\nfunction createPromise<T>(): {\n  resolve: (result: T) => unknown;\n  reject: (err: unknown) => unknown;\n  promise: Promise<T>;\n} {\n  let resolve, reject;\n  let promise = new Promise<T>((res, rej) => ([resolve, reject] = [res, rej]));\n  return { resolve, reject, promise };\n}\n\nexport async function generateStream<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema,\n>(\n  registry: Registry,\n  options:\n    | GenerateOptions<O, CustomOptions>\n    | PromiseLike<GenerateOptions<O, CustomOptions>>\n): Promise<GenerateStreamResponse<O>> {\n  let firstChunkSent = false;\n  return new Promise<GenerateStreamResponse<O>>(\n    (initialResolve, initialReject) => {\n      const {\n        resolve: finalResolve,\n        reject: finalReject,\n        promise: finalPromise,\n      } = createPromise<GenerateResponse<O>>();\n\n      let provideNextChunk, nextChunk;\n      ({ resolve: provideNextChunk, promise: nextChunk } =\n        createPromise<GenerateResponseChunk | null>());\n      async function* chunkStream(): AsyncIterable<GenerateResponseChunk> {\n        while (true) {\n          const next = await nextChunk;\n          if (!next) break;\n          yield next;\n        }\n      }\n\n      try {\n        generate<O, CustomOptions>(registry, {\n          ...options,\n          streamingCallback: (chunk) => {\n            firstChunkSent = true;\n            provideNextChunk(chunk);\n            ({ resolve: provideNextChunk, promise: nextChunk } =\n              createPromise<GenerateResponseChunk | null>());\n          },\n        })\n          .then((result) => {\n            provideNextChunk(null);\n            finalResolve(result);\n          })\n          .catch((e) => {\n            if (!firstChunkSent) {\n              initialReject(e);\n              return;\n            }\n            provideNextChunk(null);\n            finalReject(e);\n          });\n      } catch (e) {\n        if (!firstChunkSent) {\n          initialReject(e);\n          return;\n        }\n        provideNextChunk(null);\n        finalReject(e);\n      }\n\n      initialResolve({\n        get response() {\n          return finalPromise;\n        },\n        get stream() {\n          return chunkStream();\n        },\n      });\n    }\n  );\n}\n\nexport function tagAsPreamble(msgs?: MessageData[]): MessageData[] | undefined {\n  if (!msgs) {\n    return undefined;\n  }\n  return msgs.map((m) => ({\n    ...m,\n    metadata: {\n      ...m.metadata,\n      preamble: true,\n    },\n  }));\n}\n"],"mappings":"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","names":["_a","_b"]}