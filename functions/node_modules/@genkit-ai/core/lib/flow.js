"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
var flow_exports = {};
__export(flow_exports, {
  Flow: () => Flow,
  FlowServer: () => FlowServer,
  defineFlow: () => defineFlow,
  defineStreamingFlow: () => defineStreamingFlow,
  run: () => run
});
module.exports = __toCommonJS(flow_exports);
var import_api = require("@opentelemetry/api");
var bodyParser = __toESM(require("body-parser"));
var import_cors = __toESM(require("cors"));
var import_express = __toESM(require("express"));
var import_action = require("./action.js");
var import_auth = require("./auth.js");
var import_error = require("./error.js");
var import_flowTypes = require("./flowTypes.js");
var import_logging = require("./logging.js");
var import_schema = require("./schema.js");
var import_tracing = require("./tracing.js");
var import_utils = require("./utils.js");
const streamDelimiter = "\n\n";
class Flow {
  constructor(registry, config, flowFn) {
    this.registry = registry;
    this.name = config.name;
    this.inputSchema = config.inputSchema;
    this.outputSchema = config.outputSchema;
    this.streamSchema = "streamSchema" in config ? config.streamSchema : void 0;
    this.authPolicy = config.authPolicy;
    this.middleware = config.middleware;
    this.flowFn = flowFn;
  }
  /**
   * Executes the flow with the input directly.
   */
  invoke(input, opts) {
    return __async(this, null, function* () {
      yield this.registry.initializeAllPlugins();
      return yield (0, import_auth.runWithAuthContext)(
        opts.auth,
        () => (0, import_tracing.newTrace)(
          {
            name: this.name,
            labels: {
              [import_tracing.SPAN_TYPE_ATTR]: "flow"
            }
          },
          (metadata, rootSpan) => __async(this, null, function* () {
            var _a;
            if (opts.labels) {
              const labels = opts.labels;
              Object.keys(opts.labels).forEach((label) => {
                (0, import_tracing.setCustomMetadataAttribute)(
                  (0, import_utils.flowMetadataPrefix)(`label:${label}`),
                  labels[label]
                );
              });
            }
            (0, import_tracing.setCustomMetadataAttributes)({
              [(0, import_utils.flowMetadataPrefix)("name")]: this.name
            });
            try {
              metadata.input = input;
              const output = yield this.flowFn(
                input,
                (_a = opts.streamingCallback) != null ? _a : () => {
                }
              );
              metadata.output = JSON.stringify(output);
              (0, import_tracing.setCustomMetadataAttribute)((0, import_utils.flowMetadataPrefix)("state"), "done");
              return {
                result: output,
                traceId: rootSpan.spanContext().traceId,
                spanId: rootSpan.spanContext().spanId
              };
            } catch (e) {
              metadata.state = "error";
              rootSpan.setStatus({
                code: import_api.SpanStatusCode.ERROR,
                message: (0, import_error.getErrorMessage)(e)
              });
              if (e instanceof Error) {
                rootSpan.recordException(e);
              }
              (0, import_tracing.setCustomMetadataAttribute)((0, import_utils.flowMetadataPrefix)("state"), "error");
              throw e;
            }
          })
        )
      );
    });
  }
  /**
   * Runs the flow. This is used when calling a flow from another flow.
   */
  run(payload, opts) {
    return __async(this, null, function* () {
      var _a;
      const input = this.inputSchema ? this.inputSchema.parse(payload) : payload;
      yield (_a = this.authPolicy) == null ? void 0 : _a.call(this, opts == null ? void 0 : opts.withLocalAuthContext, payload);
      if (this.middleware) {
        import_logging.logger.warn(
          `Flow (${this.name}) middleware won't run when invoked with runFlow.`
        );
      }
      const result = yield this.invoke(input, {
        auth: (opts == null ? void 0 : opts.context) || (opts == null ? void 0 : opts.withLocalAuthContext)
      });
      return result.result;
    });
  }
  /**
   * Runs the flow and streams results. This is used when calling a flow from another flow.
   */
  stream(payload, opts) {
    var _a, _b;
    let chunkStreamController;
    const chunkStream = new ReadableStream({
      start(controller) {
        chunkStreamController = controller;
      },
      pull() {
      },
      cancel() {
      }
    });
    const authPromise = (_b = (_a = this.authPolicy) == null ? void 0 : _a.call(this, (opts == null ? void 0 : opts.context) || (opts == null ? void 0 : opts.withLocalAuthContext), payload)) != null ? _b : Promise.resolve();
    const invocationPromise = authPromise.then(
      () => this.invoke(
        this.inputSchema ? this.inputSchema.parse(payload) : payload,
        {
          streamingCallback: (chunk) => {
            chunkStreamController.enqueue(chunk);
          },
          auth: (opts == null ? void 0 : opts.context) || (opts == null ? void 0 : opts.withLocalAuthContext)
        }
      ).then((s) => s.result)
    ).finally(() => {
      chunkStreamController.close();
    });
    return {
      output: invocationPromise,
      stream: function() {
        return __asyncGenerator(this, null, function* () {
          const reader = chunkStream.getReader();
          while (true) {
            const chunk = yield new __await(reader.read());
            if (chunk.value) {
              yield chunk.value;
            }
            if (chunk.done) {
              break;
            }
          }
          return yield new __await(invocationPromise);
        });
      }()
    };
  }
  expressHandler(request, response) {
    return __async(this, null, function* () {
      var _a;
      const { stream } = request.query;
      const auth = request.auth;
      let input = request.body.data;
      try {
        yield (_a = this.authPolicy) == null ? void 0 : _a.call(this, auth, input);
      } catch (e) {
        const respBody = {
          error: {
            status: "PERMISSION_DENIED",
            message: e.message || "Permission denied to resource"
          }
        };
        response.status(403).send(respBody).end();
        return;
      }
      if (request.get("Accept") === "text/event-stream" || stream === "true") {
        response.writeHead(200, {
          "Content-Type": "text/plain",
          "Transfer-Encoding": "chunked"
        });
        try {
          const result = yield this.invoke(input, {
            streamingCallback: (chunk) => {
              response.write(
                "data: " + JSON.stringify({ message: chunk }) + streamDelimiter
              );
            },
            auth
          });
          response.write(
            "data: " + JSON.stringify({ result: result.result }) + streamDelimiter
          );
          response.end();
        } catch (e) {
          console.log(e);
          response.write(
            "data: " + JSON.stringify({
              error: {
                status: "INTERNAL",
                message: (0, import_error.getErrorMessage)(e),
                details: (0, import_error.getErrorStack)(e)
              }
            }) + streamDelimiter
          );
          response.end();
        }
      } else {
        try {
          const result = yield this.invoke(input, { auth });
          response.setHeader("x-genkit-trace-id", result.traceId);
          response.setHeader("x-genkit-span-id", result.spanId);
          response.status(200).send({
            result: result.result
          }).end();
        } catch (e) {
          response.status(500).send({
            error: {
              status: "INTERNAL",
              message: (0, import_error.getErrorMessage)(e),
              details: (0, import_error.getErrorStack)(e)
            }
          }).end();
        }
      }
    });
  }
}
const _FlowServer = class _FlowServer {
  constructor(registry, options) {
    /** Port the server is actually running on. This may differ from `options.port` if the original was occupied. Null is server is not running. */
    this.port = null;
    /** Express server instance. Null if server is not running. */
    this.server = null;
    this.registry = registry;
    this.options = __spreadValues({}, options);
  }
  /**
   * Starts the server and adds it to the list of running servers to clean up on exit.
   */
  start() {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const server = (0, import_express.default)();
      server.use(bodyParser.json(this.options.jsonParserOptions));
      server.use((0, import_cors.default)(this.options.cors));
      if (!!this.options.flows) {
        import_logging.logger.debug("Running flow server with flow paths:");
        const pathPrefix = (_a = this.options.pathPrefix) != null ? _a : "";
        (_b = this.options.flows) == null ? void 0 : _b.forEach((flow) => {
          var _a2;
          const flowPath = `/${pathPrefix}${flow.flow.name}`;
          import_logging.logger.debug(` - ${flowPath}`);
          (_a2 = flow.flow.middleware) == null ? void 0 : _a2.forEach(
            (middleware) => server.post(flowPath, middleware)
          );
          server.post(flowPath, (req, res) => flow.flow.expressHandler(req, res));
        });
      } else {
        import_logging.logger.warn("No flows registered in flow server.");
      }
      this.port = ((_c = this.options) == null ? void 0 : _c.port) || (process.env.PORT ? parseInt(process.env.PORT) : 0) || 3400;
      this.server = server.listen(this.port, () => {
        import_logging.logger.debug(`Flow server running on http://localhost:${this.port}`);
        _FlowServer.RUNNING_SERVERS.push(this);
      });
    });
  }
  /**
   * Stops the server and removes it from the list of running servers to clean up on exit.
   */
  stop() {
    return __async(this, null, function* () {
      if (!this.server) {
        return;
      }
      return new Promise((resolve, reject) => {
        this.server.close((err) => {
          if (err) {
            import_logging.logger.error(
              `Error shutting down flow server on port ${this.port}: ${err}`
            );
            reject(err);
          }
          const index = _FlowServer.RUNNING_SERVERS.indexOf(this);
          if (index > -1) {
            _FlowServer.RUNNING_SERVERS.splice(index, 1);
          }
          import_logging.logger.debug(
            `Flow server on port ${this.port} has successfully shut down.`
          );
          this.port = null;
          this.server = null;
          resolve();
        });
      });
    });
  }
  /**
   * Stops all running servers.
   */
  static stopAll() {
    return __async(this, null, function* () {
      return Promise.all(
        _FlowServer.RUNNING_SERVERS.map((server) => server.stop())
      );
    });
  }
};
/** List of all running servers needed to be cleaned up on process exit. */
_FlowServer.RUNNING_SERVERS = [];
let FlowServer = _FlowServer;
function defineFlow(registry, config, fn) {
  const resolvedConfig = typeof config === "string" ? { name: config } : config;
  const flow = new Flow(registry, resolvedConfig, fn);
  registerFlowAction(registry, flow);
  const callableFlow = (input, opts) => __async(this, null, function* () {
    return flow.run(input, opts);
  });
  callableFlow.flow = flow;
  callableFlow.stream = (input, opts) => {
    return flow.stream(input, opts);
  };
  return callableFlow;
}
function defineStreamingFlow(registry, config, fn) {
  const flow = new Flow(registry, config, fn);
  registerFlowAction(registry, flow);
  const streamableFlow = (input, opts) => {
    return flow.stream(input, opts);
  };
  streamableFlow.flow = flow;
  return streamableFlow;
}
function registerFlowAction(registry, flow) {
  return (0, import_action.defineAction)(
    registry,
    {
      actionType: "flow",
      name: flow.name,
      inputSchema: import_flowTypes.FlowActionInputSchema,
      outputSchema: flow.outputSchema,
      metadata: {
        inputSchema: (0, import_schema.toJsonSchema)({ schema: flow.inputSchema }),
        outputSchema: (0, import_schema.toJsonSchema)({ schema: flow.outputSchema }),
        requiresAuth: !!flow.authPolicy
      }
    },
    (envelope) => __async(this, null, function* () {
      var _a, _b, _c, _d;
      yield (_b = flow.authPolicy) == null ? void 0 : _b.call(
        flow,
        envelope.auth,
        (_a = envelope.start) == null ? void 0 : _a.input
      );
      (0, import_tracing.setCustomMetadataAttribute)((0, import_utils.flowMetadataPrefix)("wrapperAction"), "true");
      const response = yield flow.invoke((_c = envelope.start) == null ? void 0 : _c.input, {
        streamingCallback: (0, import_action.getStreamingCallback)(),
        auth: envelope.auth,
        labels: (_d = envelope.start) == null ? void 0 : _d.labels
      });
      return response.result;
    })
  );
}
function run(name, funcOrInput, fn) {
  var _arguments = arguments;
  const func = arguments.length === 3 ? fn : funcOrInput;
  const input = arguments.length === 3 ? funcOrInput : void 0;
  if (!func) {
    throw new Error("unable to resolve run function");
  }
  return (0, import_tracing.runInNewSpan)(
    {
      metadata: { name },
      labels: {
        [import_tracing.SPAN_TYPE_ATTR]: "flowStep"
      }
    },
    (meta) => __async(this, null, function* () {
      meta.input = input;
      const output = _arguments.length === 3 ? yield func(input) : yield func();
      meta.output = JSON.stringify(output);
      return output;
    })
  );
}
if (typeof module !== "undefined" && "hot" in module) {
  module.hot.accept();
  module.hot.dispose(() => __async(void 0, null, function* () {
    import_logging.logger.debug("Cleaning up flow server(s) before module reload...");
    yield FlowServer.stopAll();
  }));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Flow,
  FlowServer,
  defineFlow,
  defineStreamingFlow,
  run
});
//# sourceMappingURL=flow.js.map