{"version":3,"sources":["../src/reflection.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express from 'express';\nimport fs from 'fs/promises';\nimport getPort, { makeRange } from 'get-port';\nimport { Server } from 'http';\nimport path from 'path';\nimport z from 'zod';\nimport { Status, StatusCodes, runWithStreamingCallback } from './action.js';\nimport { GENKIT_VERSION } from './index.js';\nimport { logger } from './logging.js';\nimport { Registry } from './registry.js';\nimport { toJsonSchema } from './schema.js';\nimport { flushTracing, setTelemetryServerUrl } from './tracing.js';\n\n// TODO: Move this to common location for schemas.\nexport const RunActionResponseSchema = z.object({\n  result: z.unknown().optional(),\n  error: z.unknown().optional(),\n  telemetry: z\n    .object({\n      traceId: z.string().optional(),\n    })\n    .optional(),\n});\nexport type RunActionResponse = z.infer<typeof RunActionResponseSchema>;\n\nexport interface ReflectionServerOptions {\n  /** Port to run the server on. Actual port may be different if chosen port is occupied. Defaults to 3100. */\n  port?: number;\n  /** Body size limit for the server. Defaults to `30mb`. */\n  bodyLimit?: string;\n  /** Configured environments. Defaults to `dev`. */\n  configuredEnvs?: string[];\n}\n\n/**\n * Reflection server exposes an API for inspecting and interacting with Genkit in development.\n *\n * This is for use in development environments.\n */\nexport class ReflectionServer {\n  /** List of all running servers needed to be cleaned up on process exit. */\n  private static RUNNING_SERVERS: ReflectionServer[] = [];\n\n  /** Registry instance to be used for API calls. */\n  private registry: Registry;\n  /** Options for the reflection server. */\n  private options: ReflectionServerOptions;\n  /** Port the server is actually running on. This may differ from `options.port` if the original was occupied. Null if server is not running. */\n  private port: number | null = null;\n  /** Express server instance. Null if server is not running. */\n  private server: Server | null = null;\n  /** Path to the runtime file. Null if server is not running. */\n  private runtimeFilePath: string | null = null;\n\n  constructor(registry: Registry, options?: ReflectionServerOptions) {\n    this.registry = registry;\n    this.options = {\n      port: 3100,\n      bodyLimit: '30mb',\n      configuredEnvs: ['dev'],\n      ...options,\n    };\n  }\n\n  /**\n   * Finds a free port to run the server on based on the original chosen port and environment.\n   */\n  async findPort(): Promise<number> {\n    const chosenPort = this.options.port!;\n    const freePort = await getPort({\n      port: makeRange(chosenPort, chosenPort + 100),\n    });\n    if (freePort !== chosenPort) {\n      logger.warn(\n        `Port ${chosenPort} is already in use, using next available port ${freePort} instead.`\n      );\n    }\n    return freePort;\n  }\n\n  /**\n   * Starts the server.\n   *\n   * The server will be registered to be shut down on process exit.\n   */\n  async start() {\n    const server = express();\n\n    server.use(express.json({ limit: this.options.bodyLimit }));\n    server.use(function (req, res, next) {\n      res.header('x-genkit-version', GENKIT_VERSION);\n      next();\n    });\n\n    server.get('/api/__health', async (_, response) => {\n      await this.registry.listActions();\n      response.status(200).send('OK');\n    });\n\n    server.get('/api/__quitquitquit', async (_, response) => {\n      logger.debug('Received quitquitquit');\n      response.status(200).send('OK');\n      await this.stop();\n    });\n\n    server.get('/api/actions', async (_, response, next) => {\n      logger.debug('Fetching actions.');\n      try {\n        const actions = await this.registry.listActions();\n        const convertedActions = {};\n        Object.keys(actions).forEach((key) => {\n          const action = actions[key].__action;\n          convertedActions[key] = {\n            key,\n            name: action.name,\n            description: action.description,\n            metadata: action.metadata,\n          };\n          if (action.inputSchema || action.inputJsonSchema) {\n            convertedActions[key].inputSchema = toJsonSchema({\n              schema: action.inputSchema,\n              jsonSchema: action.inputJsonSchema,\n            });\n          }\n          if (action.outputSchema || action.outputJsonSchema) {\n            convertedActions[key].outputSchema = toJsonSchema({\n              schema: action.outputSchema,\n              jsonSchema: action.outputJsonSchema,\n            });\n          }\n        });\n        response.send(convertedActions);\n      } catch (err) {\n        const { message, stack } = err as Error;\n        next({ message, stack });\n      }\n    });\n\n    server.post('/api/runAction', async (request, response, next) => {\n      const { key, input } = request.body;\n      const { stream } = request.query;\n      logger.debug(`Running action \\`${key}\\` with stream=${stream}...`);\n      let traceId;\n      try {\n        const action = await this.registry.lookupAction(key);\n        if (!action) {\n          response.status(404).send(`action ${key} not found`);\n          return;\n        }\n        if (stream === 'true') {\n          const result = await runWithStreamingCallback(\n            (chunk) => {\n              response.write(JSON.stringify(chunk) + '\\n');\n            },\n            async () => await action.run(input)\n          );\n          await flushTracing();\n          response.write(\n            JSON.stringify({\n              result: result.result,\n              telemetry: {\n                traceId: result.telemetry.traceId,\n              },\n            } as RunActionResponse)\n          );\n          response.end();\n        } else {\n          const result = await action.run(input);\n          await flushTracing();\n          response.send({\n            result: result.result,\n            telemetry: {\n              traceId: result.telemetry.traceId,\n            },\n          } as RunActionResponse);\n        }\n      } catch (err) {\n        const { message, stack } = err as Error;\n        next({ message, stack, traceId });\n      }\n    });\n\n    server.get('/api/envs', async (_, response) => {\n      response.json(this.options.configuredEnvs);\n    });\n\n    server.post('/api/notify', async (request, response) => {\n      const { telemetryServerUrl } = request.body;\n      if (typeof telemetryServerUrl === 'string') {\n        setTelemetryServerUrl(telemetryServerUrl);\n        logger.debug(`Connected to telemetry server on ${telemetryServerUrl}`);\n      }\n      response.status(200).send('OK');\n    });\n\n    server.use((err, req, res, next) => {\n      logger.error(err.stack);\n      const error = err as Error;\n      const { message, stack } = error;\n      const errorResponse: Status = {\n        code: StatusCodes.INTERNAL,\n        message,\n        details: {\n          stack,\n        },\n      };\n      if (err.traceId) {\n        errorResponse.details.traceId = err.traceId;\n      }\n      res.status(500).json(errorResponse);\n    });\n\n    this.port = await this.findPort();\n    this.server = server.listen(this.port, async () => {\n      logger.debug(\n        `Reflection server (${process.pid}) running on http://localhost:${this.port}`\n      );\n      ReflectionServer.RUNNING_SERVERS.push(this);\n      await this.writeRuntimeFile();\n    });\n  }\n\n  /**\n   * Stops the server and removes it from the list of running servers to clean up on exit.\n   */\n  async stop(): Promise<void> {\n    if (!this.server) {\n      return;\n    }\n    return new Promise<void>(async (resolve, reject) => {\n      await this.cleanupRuntimeFile();\n      this.server!.close(async (err) => {\n        if (err) {\n          logger.error(\n            `Error shutting down reflection server on port ${this.port}: ${err}`\n          );\n          reject(err);\n        }\n        const index = ReflectionServer.RUNNING_SERVERS.indexOf(this);\n        if (index > -1) {\n          ReflectionServer.RUNNING_SERVERS.splice(index, 1);\n        }\n        logger.debug(\n          `Reflection server on port ${this.port} has successfully shut down.`\n        );\n        this.port = null;\n        this.server = null;\n        resolve();\n      });\n    });\n  }\n\n  /**\n   * Writes the runtime file to the project root.\n   */\n  private async writeRuntimeFile() {\n    try {\n      const rootDir = await findProjectRoot();\n      const runtimesDir = path.join(rootDir, '.genkit', 'runtimes');\n      const date = new Date();\n      const time = date.getTime();\n      const timestamp = date.toISOString();\n      this.runtimeFilePath = path.join(\n        runtimesDir,\n        `${process.pid}-${time}.json`\n      );\n      const fileContent = JSON.stringify(\n        {\n          id: process.env.GENKIT_RUNTIME_ID || process.pid.toString(),\n          pid: process.pid,\n          reflectionServerUrl: `http://localhost:${this.port}`,\n          timestamp,\n        },\n        null,\n        2\n      );\n      await fs.mkdir(runtimesDir, { recursive: true });\n      await fs.writeFile(this.runtimeFilePath, fileContent, 'utf8');\n      logger.debug(`Runtime file written: ${this.runtimeFilePath}`);\n    } catch (error) {\n      logger.error(`Error writing runtime file: ${error}`);\n    }\n  }\n\n  /**\n   * Cleans up the port file.\n   */\n  private async cleanupRuntimeFile() {\n    if (!this.runtimeFilePath) {\n      return;\n    }\n    try {\n      const fileContent = await fs.readFile(this.runtimeFilePath, 'utf8');\n      const data = JSON.parse(fileContent);\n      if (data.pid === process.pid) {\n        await fs.unlink(this.runtimeFilePath);\n        logger.debug(`Runtime file cleaned up: ${this.runtimeFilePath}`);\n      }\n    } catch (error) {\n      logger.error(`Error cleaning up runtime file: ${error}`);\n    }\n  }\n\n  /**\n   * Stops all running reflection servers.\n   */\n  static async stopAll() {\n    return Promise.all(\n      ReflectionServer.RUNNING_SERVERS.map((server) => server.stop())\n    );\n  }\n}\n\n/**\n * Finds the project root by looking for a `package.json` file.\n */\nasync function findProjectRoot(): Promise<string> {\n  let currentDir = process.cwd();\n  while (currentDir !== path.parse(currentDir).root) {\n    const packageJsonPath = path.join(currentDir, 'package.json');\n    try {\n      await fs.access(packageJsonPath);\n      return currentDir;\n    } catch {\n      currentDir = path.dirname(currentDir);\n    }\n  }\n  throw new Error('Could not find project root (package.json not found)');\n}\n\n// TODO: Verify that this works.\nif (typeof module !== 'undefined' && 'hot' in module) {\n  (module as any).hot.accept();\n  (module as any).hot.dispose(async () => {\n    logger.debug('Cleaning up reflection server(s) before module reload...');\n    await ReflectionServer.stopAll();\n  });\n}\n"],"mappings":"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","names":["z","getPort","express","path","fs"]}