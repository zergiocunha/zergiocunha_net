{"version":3,"sources":["../src/action.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JSONSchema7 } from 'json-schema';\nimport { AsyncLocalStorage } from 'node:async_hooks';\nimport * as z from 'zod';\nimport { ActionType, Registry } from './registry.js';\nimport { parseSchema } from './schema.js';\nimport {\n  SPAN_TYPE_ATTR,\n  newTrace,\n  setCustomMetadataAttributes,\n} from './tracing.js';\n\nexport { Status, StatusCodes, StatusSchema } from './statusTypes.js';\nexport { JSONSchema7 };\n\n/**\n * Action metadata.\n */\nexport interface ActionMetadata<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny,\n> {\n  actionType?: ActionType;\n  name: string;\n  description?: string;\n  inputSchema?: I;\n  inputJsonSchema?: JSONSchema7;\n  outputSchema?: O;\n  outputJsonSchema?: JSONSchema7;\n  streamSchema?: S;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Results of an action run. Includes telemetry.\n */\nexport interface ActionResult<O> {\n  result: O;\n  telemetry: {\n    traceId: string;\n    spanId: string;\n  };\n}\n\n/**\n * Options (side channel) data to pass to the model.\n */\nexport interface ActionRunOptions<S> {\n  /**\n   * Streaming callback (optional).\n   */\n  onChunk?: StreamingCallback<S>;\n\n  /**\n   * Additional runtime context data (ex. auth context data).\n   */\n  context?: any;\n}\n\n/**\n * Options (side channel) data to pass to the model.\n */\nexport interface ActionFnArg<S> {\n  /**\n   * Streaming callback (optional).\n   */\n  sendChunk: StreamingCallback<S>;\n\n  /**\n   * Additional runtime context data (ex. auth context data).\n   */\n  context?: any;\n}\n\n/**\n * Self-describing, validating, observable, locally and remotely callable function.\n */\nexport type Action<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> = ((\n  input: z.infer<I>,\n  options?: ActionRunOptions<S>\n) => Promise<z.infer<O>>) & {\n  __action: ActionMetadata<I, O, S>;\n  run(\n    input: z.infer<I>,\n    options?: ActionRunOptions<z.infer<S>>\n  ): Promise<ActionResult<z.infer<O>>>;\n};\n\n/**\n * Action factory params.\n */\ntype ActionParams<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> = {\n  name:\n    | string\n    | {\n        pluginId: string;\n        actionId: string;\n      };\n  description?: string;\n  inputSchema?: I;\n  inputJsonSchema?: JSONSchema7;\n  outputSchema?: O;\n  outputJsonSchema?: JSONSchema7;\n  metadata?: Record<string, any>;\n  use?: Middleware<z.infer<I>, z.infer<O>, z.infer<S>>[];\n  streamingSchema?: S;\n};\n\nexport type SimpleMiddleware<I = any, O = any> = (\n  req: I,\n  next: (req?: I) => Promise<O>\n) => Promise<O>;\n\nexport type MiddlewareWithOptions<I = any, O = any, S = any> = (\n  req: I,\n  options: ActionRunOptions<S> | undefined,\n  next: (req?: I, options?: ActionRunOptions<S>) => Promise<O>\n) => Promise<O>;\n\n/**\n * Middleware function for actions.\n */\nexport type Middleware<I = any, O = any, S = any> =\n  | SimpleMiddleware<I, O>\n  | MiddlewareWithOptions<I, O, S>;\n\n/**\n * Creates an action with provided middleware.\n */\nexport function actionWithMiddleware<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  action: Action<I, O, S>,\n  middleware: Middleware<z.infer<I>, z.infer<O>, z.infer<S>>[]\n): Action<I, O, S> {\n  const wrapped = (async (req: z.infer<I>) => {\n    return (await wrapped.run(req)).result;\n  }) as Action<I, O, S>;\n  wrapped.__action = action.__action;\n  wrapped.run = async (\n    req: z.infer<I>,\n    options?: ActionRunOptions<z.infer<S>>\n  ): Promise<ActionResult<z.infer<O>>> => {\n    let telemetry;\n    const dispatch = async (\n      index: number,\n      req: z.infer<I>,\n      opts?: ActionRunOptions<z.infer<S>>\n    ) => {\n      if (index === middleware.length) {\n        // end of the chain, call the original model action\n        const result = await action.run(req, opts);\n        telemetry = result.telemetry;\n        return result.result;\n      }\n\n      const currentMiddleware = middleware[index];\n      if (currentMiddleware.length === 3) {\n        return (currentMiddleware as MiddlewareWithOptions<I, O, z.infer<S>>)(\n          req,\n          opts,\n          async (modifiedReq, modifiedOptions) =>\n            dispatch(index + 1, modifiedReq || req, modifiedOptions || opts)\n        );\n      } else if (currentMiddleware.length === 2) {\n        return (currentMiddleware as SimpleMiddleware<I, O>)(\n          req,\n          async (modifiedReq) => dispatch(index + 1, modifiedReq || req, opts)\n        );\n      } else {\n        throw new Error('unspported middleware function shape');\n      }\n    };\n\n    return { result: await dispatch(0, req, options), telemetry };\n  };\n  return wrapped;\n}\n\n/**\n * Creates an action with the provided config.\n */\nexport function action<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  config: ActionParams<I, O, S>,\n  fn: (\n    input: z.infer<I>,\n    options: ActionFnArg<z.infer<S>>\n  ) => Promise<z.infer<O>>\n): Action<I, O, z.infer<S>> {\n  const actionName =\n    typeof config.name === 'string'\n      ? config.name\n      : `${config.name.pluginId}/${config.name.actionId}`;\n  const actionFn = async (input: I, options?: ActionRunOptions<z.infer<S>>) => {\n    return (await actionFn.run(input, options)).result;\n  };\n  actionFn.__action = {\n    name: actionName,\n    description: config.description,\n    inputSchema: config.inputSchema,\n    inputJsonSchema: config.inputJsonSchema,\n    outputSchema: config.outputSchema,\n    outputJsonSchema: config.outputJsonSchema,\n    metadata: config.metadata,\n  } as ActionMetadata<I, O, S>;\n  actionFn.run = async (\n    input: z.infer<I>,\n    options?: ActionRunOptions<z.infer<S>>\n  ): Promise<ActionResult<z.infer<O>>> => {\n    input = parseSchema(input, {\n      schema: config.inputSchema,\n      jsonSchema: config.inputJsonSchema,\n    });\n    let traceId;\n    let spanId;\n    let output = await newTrace(\n      {\n        name: actionName,\n        labels: {\n          [SPAN_TYPE_ATTR]: 'action',\n        },\n      },\n      async (metadata, span) => {\n        traceId = span.spanContext().traceId;\n        spanId = span.spanContext().spanId;\n        metadata.name = actionName;\n        metadata.input = input;\n\n        const output = await fn(input, {\n          context: options?.context,\n          sendChunk: options?.onChunk ?? ((c) => {}),\n        });\n\n        metadata.output = JSON.stringify(output);\n        return output;\n      }\n    );\n    output = parseSchema(output, {\n      schema: config.outputSchema,\n      jsonSchema: config.outputJsonSchema,\n    });\n    return {\n      result: output,\n      telemetry: {\n        traceId,\n        spanId,\n      },\n    };\n  };\n\n  if (config.use) {\n    return actionWithMiddleware(actionFn, config.use);\n  }\n  return actionFn;\n}\n\nfunction validateActionName(registry: Registry, name: string) {\n  if (name.includes('/')) {\n    validatePluginName(registry, name.split('/', 1)[0]);\n    validateActionId(name.substring(name.indexOf('/') + 1));\n  }\n  return name;\n}\n\nfunction validatePluginName(registry: Registry, pluginId: string) {\n  if (!registry.lookupPlugin(pluginId)) {\n    throw new Error(\n      `Unable to find plugin name used in the action name: ${pluginId}`\n    );\n  }\n  return pluginId;\n}\n\nfunction validateActionId(actionId: string) {\n  if (actionId.includes('/')) {\n    throw new Error(`Action name must not include slashes (/): ${actionId}`);\n  }\n  return actionId;\n}\n\n/**\n * Defines an action with the given config and registers it in the registry.\n */\nexport function defineAction<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  registry: Registry,\n  config: ActionParams<I, O, S> & {\n    actionType: ActionType;\n  },\n  fn: (\n    input: z.infer<I>,\n    options: ActionFnArg<z.infer<S>>\n  ) => Promise<z.infer<O>>\n): Action<I, O> {\n  if (isInRuntimeContext()) {\n    throw new Error(\n      'Cannot define new actions at runtime.\\n' +\n        'See: https://github.com/firebase/genkit/blob/main/docs/errors/no_new_actions_at_runtime.md'\n    );\n  }\n  if (typeof config.name === 'string') {\n    validateActionName(registry, config.name);\n  } else {\n    validateActionId(config.name.actionId);\n  }\n  const act = action(config, async (i: I, options): Promise<z.infer<O>> => {\n    setCustomMetadataAttributes({ subtype: config.actionType });\n    await registry.initializeAllPlugins();\n    return await runInActionRuntimeContext(() => fn(i, options));\n  });\n  act.__action.actionType = config.actionType;\n  registry.registerAction(config.actionType, act);\n  return act;\n}\n\n// Streaming callback function.\nexport type StreamingCallback<T> = (chunk: T) => void;\n\nconst streamingAls = new AsyncLocalStorage<StreamingCallback<any>>();\nconst sentinelNoopCallback = () => null;\n\n/**\n * Executes provided function with streaming callback in async local storage which can be retrieved\n * using {@link getStreamingCallback}.\n */\nexport function runWithStreamingCallback<S, O>(\n  streamingCallback: StreamingCallback<S> | undefined,\n  fn: () => O\n): O {\n  return streamingAls.run(streamingCallback || sentinelNoopCallback, fn);\n}\n\n/**\n * Retrieves the {@link StreamingCallback} previously set by {@link runWithStreamingCallback}\n */\nexport function getStreamingCallback<S>(): StreamingCallback<S> | undefined {\n  const cb = streamingAls.getStore();\n  if (cb === sentinelNoopCallback) {\n    return undefined;\n  }\n  return cb;\n}\n\nconst runtimeCtxAls = new AsyncLocalStorage<any>();\n\n/**\n * Checks whether the caller is currently in the runtime context of an action.\n */\nexport function isInRuntimeContext() {\n  return !!runtimeCtxAls.getStore();\n}\n\n/**\n * Execute the provided function in the action runtime context.\n */\nexport function runInActionRuntimeContext<R>(fn: () => R) {\n  return runtimeCtxAls.run('runtime', fn);\n}\n"],"mappings":"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","names":["action","req","output"]}