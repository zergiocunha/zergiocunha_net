{"version":3,"sources":["../src/flow.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanStatusCode } from '@opentelemetry/api';\nimport * as bodyParser from 'body-parser';\nimport cors, { CorsOptions } from 'cors';\nimport express from 'express';\nimport { Server } from 'http';\nimport { z } from 'zod';\nimport {\n  Action,\n  defineAction,\n  getStreamingCallback,\n  StreamingCallback,\n} from './action.js';\nimport { runWithAuthContext } from './auth.js';\nimport { getErrorMessage, getErrorStack } from './error.js';\nimport { FlowActionInputSchema } from './flowTypes.js';\nimport { logger } from './logging.js';\nimport { Registry } from './registry.js';\nimport { toJsonSchema } from './schema.js';\nimport {\n  newTrace,\n  runInNewSpan,\n  setCustomMetadataAttribute,\n  setCustomMetadataAttributes,\n  SPAN_TYPE_ATTR,\n} from './tracing.js';\nimport { flowMetadataPrefix } from './utils.js';\n\nconst streamDelimiter = '\\n\\n';\n\n/**\n * Flow Auth policy. Consumes the authorization context of the flow and\n * performs checks before the flow runs. If this throws, the flow will not\n * be executed.\n */\nexport interface FlowAuthPolicy<I extends z.ZodTypeAny = z.ZodTypeAny> {\n  (auth: any | undefined, input: z.infer<I>): void | Promise<void>;\n}\n\n/**\n * For express-based flows, req.auth should contain the value to bepassed into\n * the flow context.\n */\nexport interface __RequestWithAuth extends express.Request {\n  auth?: unknown;\n}\n\n/**\n * Configuration for a flow.\n */\nexport interface FlowConfig<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  /** Name of the flow. */\n  name: string;\n  /** Schema of the input to the flow. */\n  inputSchema?: I;\n  /** Schema of the output from the flow. */\n  outputSchema?: O;\n  /** Auth policy. */\n  authPolicy?: FlowAuthPolicy<I>;\n  /** Middleware for HTTP requests. Not called for direct invocations. */\n  middleware?: express.RequestHandler[];\n}\n\n/**\n * Configuration for a streaming flow.\n */\nexport interface StreamingFlowConfig<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> extends FlowConfig<I, O> {\n  /** Schema of the streaming chunks from the flow. */\n  streamSchema?: S;\n}\n\nexport interface FlowCallOptions {\n  /** @deprecated use {@link context} instead. */\n  withLocalAuthContext?: unknown;\n  context?: unknown;\n}\n\n/**\n * Non-streaming flow that can be called directly like a function.\n */\nexport interface CallableFlow<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  (input?: z.infer<I>, opts?: FlowCallOptions): Promise<z.infer<O>>;\n\n  stream(input?: z.infer<I>, opts?: FlowCallOptions): StreamingResponse<O, S>;\n\n  flow: Flow<I, O, z.ZodVoid>;\n}\n\n/**\n * Streaming flow that can be called directly like a function.\n * @deprecated use {@link CallableFlow}\n */\nexport interface StreamableFlow<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  (input?: z.infer<I>, opts?: FlowCallOptions): StreamingResponse<O, S>;\n  flow: Flow<I, O, S>;\n}\n\n/**\n * Response from a streaming flow.\n */\ninterface StreamingResponse<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  /** Iterator over the streaming chunks. */\n  stream: AsyncGenerator<z.infer<S>>;\n  /** Final output of the flow. */\n  output: Promise<z.infer<O>>;\n}\n\n/**\n * Function to be executed in the flow.\n */\nexport type FlowFn<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> = (\n  /** Input to the flow. */\n  input: z.infer<I>,\n  /** Callback for streaming functions only. */\n  streamingCallback: StreamingCallback<z.infer<S>>\n) => Promise<z.infer<O>> | z.infer<O>;\n\n/**\n * Represents the result of a flow execution.\n */\ninterface FlowResult<O> {\n  /** The result of the flow execution. */\n  result: O;\n  /** The trace ID associated with the flow execution. */\n  traceId: string;\n  /** The root span ID of the associated trace. */\n  spanId: string;\n}\n\nexport class Flow<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  readonly name: string;\n  readonly inputSchema?: I;\n  readonly outputSchema?: O;\n  readonly streamSchema?: S;\n  readonly authPolicy?: FlowAuthPolicy<I>;\n  readonly middleware?: express.RequestHandler[];\n  readonly flowFn: FlowFn<I, O, S>;\n\n  constructor(\n    private registry: Registry,\n    config: FlowConfig<I, O> | StreamingFlowConfig<I, O, S>,\n    flowFn: FlowFn<I, O, S>\n  ) {\n    this.name = config.name;\n    this.inputSchema = config.inputSchema;\n    this.outputSchema = config.outputSchema;\n    this.streamSchema =\n      'streamSchema' in config ? config.streamSchema : undefined;\n    this.authPolicy = config.authPolicy;\n    this.middleware = config.middleware;\n    this.flowFn = flowFn;\n  }\n\n  /**\n   * Executes the flow with the input directly.\n   */\n  async invoke(\n    input: unknown,\n    opts: {\n      streamingCallback?: StreamingCallback<z.infer<S>>;\n      labels?: Record<string, string>;\n      auth?: unknown;\n    }\n  ): Promise<FlowResult<z.infer<O>>> {\n    await this.registry.initializeAllPlugins();\n    return await runWithAuthContext(opts.auth, () =>\n      newTrace(\n        {\n          name: this.name,\n          labels: {\n            [SPAN_TYPE_ATTR]: 'flow',\n          },\n        },\n        async (metadata, rootSpan) => {\n          if (opts.labels) {\n            const labels = opts.labels;\n            Object.keys(opts.labels).forEach((label) => {\n              setCustomMetadataAttribute(\n                flowMetadataPrefix(`label:${label}`),\n                labels[label]\n              );\n            });\n          }\n\n          setCustomMetadataAttributes({\n            [flowMetadataPrefix('name')]: this.name,\n          });\n          try {\n            metadata.input = input;\n            const output = await this.flowFn(\n              input,\n              opts.streamingCallback ?? (() => {})\n            );\n            metadata.output = JSON.stringify(output);\n            setCustomMetadataAttribute(flowMetadataPrefix('state'), 'done');\n            return {\n              result: output,\n              traceId: rootSpan.spanContext().traceId,\n              spanId: rootSpan.spanContext().spanId,\n            };\n          } catch (e) {\n            metadata.state = 'error';\n            rootSpan.setStatus({\n              code: SpanStatusCode.ERROR,\n              message: getErrorMessage(e),\n            });\n            if (e instanceof Error) {\n              rootSpan.recordException(e);\n            }\n\n            setCustomMetadataAttribute(flowMetadataPrefix('state'), 'error');\n            throw e;\n          }\n        }\n      )\n    );\n  }\n\n  /**\n   * Runs the flow. This is used when calling a flow from another flow.\n   */\n  async run(payload?: z.infer<I>, opts?: FlowCallOptions): Promise<z.infer<O>> {\n    const input = this.inputSchema ? this.inputSchema.parse(payload) : payload;\n    await this.authPolicy?.(opts?.withLocalAuthContext, payload);\n\n    if (this.middleware) {\n      logger.warn(\n        `Flow (${this.name}) middleware won't run when invoked with runFlow.`\n      );\n    }\n\n    const result = await this.invoke(input, {\n      auth: opts?.context || opts?.withLocalAuthContext,\n    });\n    return result.result;\n  }\n\n  /**\n   * Runs the flow and streams results. This is used when calling a flow from another flow.\n   */\n  stream(\n    payload?: z.infer<I>,\n    opts?: FlowCallOptions\n  ): StreamingResponse<O, S> {\n    let chunkStreamController: ReadableStreamController<z.infer<S>>;\n    const chunkStream = new ReadableStream<z.infer<S>>({\n      start(controller) {\n        chunkStreamController = controller;\n      },\n      pull() {},\n      cancel() {},\n    });\n\n    const authPromise =\n      this.authPolicy?.(opts?.context || opts?.withLocalAuthContext, payload) ??\n      Promise.resolve();\n\n    const invocationPromise = authPromise\n      .then(() =>\n        this.invoke(\n          this.inputSchema ? this.inputSchema.parse(payload) : payload,\n          {\n            streamingCallback: ((chunk: z.infer<S>) => {\n              chunkStreamController.enqueue(chunk);\n            }) as S extends z.ZodVoid\n              ? undefined\n              : StreamingCallback<z.infer<S>>,\n            auth: opts?.context || opts?.withLocalAuthContext,\n          }\n        ).then((s) => s.result)\n      )\n      .finally(() => {\n        chunkStreamController.close();\n      });\n\n    return {\n      output: invocationPromise,\n      stream: (async function* () {\n        const reader = chunkStream.getReader();\n        while (true) {\n          const chunk = await reader.read();\n          if (chunk.value) {\n            yield chunk.value;\n          }\n          if (chunk.done) {\n            break;\n          }\n        }\n        return await invocationPromise;\n      })(),\n    };\n  }\n\n  async expressHandler(\n    request: __RequestWithAuth,\n    response: express.Response\n  ): Promise<void> {\n    const { stream } = request.query;\n    const auth = request.auth;\n\n    let input = request.body.data;\n\n    try {\n      await this.authPolicy?.(auth, input);\n    } catch (e: any) {\n      const respBody = {\n        error: {\n          status: 'PERMISSION_DENIED',\n          message: e.message || 'Permission denied to resource',\n        },\n      };\n      response.status(403).send(respBody).end();\n      return;\n    }\n\n    if (request.get('Accept') === 'text/event-stream' || stream === 'true') {\n      response.writeHead(200, {\n        'Content-Type': 'text/plain',\n        'Transfer-Encoding': 'chunked',\n      });\n      try {\n        const result = await this.invoke(input, {\n          streamingCallback: (chunk: z.infer<S>) => {\n            response.write(\n              'data: ' + JSON.stringify({ message: chunk }) + streamDelimiter\n            );\n          },\n          auth,\n        });\n        response.write(\n          'data: ' + JSON.stringify({ result: result.result }) + streamDelimiter\n        );\n        response.end();\n      } catch (e) {\n        console.log(e);\n        response.write(\n          'data: ' +\n            JSON.stringify({\n              error: {\n                status: 'INTERNAL',\n                message: getErrorMessage(e),\n                details: getErrorStack(e),\n              },\n            }) +\n            streamDelimiter\n        );\n        response.end();\n      }\n    } else {\n      try {\n        const result = await this.invoke(input, { auth });\n        response.setHeader('x-genkit-trace-id', result.traceId);\n        response.setHeader('x-genkit-span-id', result.spanId);\n        // Responses for non-streaming flows are passed back with the flow result stored in a field called \"result.\"\n        response\n          .status(200)\n          .send({\n            result: result.result,\n          })\n          .end();\n      } catch (e) {\n        // Errors for non-streaming flows are passed back as standard API errors.\n        response\n          .status(500)\n          .send({\n            error: {\n              status: 'INTERNAL',\n              message: getErrorMessage(e),\n              details: getErrorStack(e),\n            },\n          })\n          .end();\n      }\n    }\n  }\n}\n\n/**\n * Options to configure the flow server.\n */\nexport interface FlowServerOptions {\n  /** List of flows to expose via the flow server. */\n  flows: (CallableFlow<any, any> | StreamableFlow<any, any>)[];\n  /** Port to run the server on. Defaults to env.PORT or 3400. */\n  port?: number;\n  /** CORS options for the server. */\n  cors?: CorsOptions;\n  /** HTTP method path prefix for the exposed flows. */\n  pathPrefix?: string;\n  /** JSON body parser options. */\n  jsonParserOptions?: bodyParser.OptionsJson;\n}\n\n/**\n * Flow server exposes registered flows as HTTP endpoints.\n *\n * This is for use in production environments.\n */\nexport class FlowServer {\n  /** List of all running servers needed to be cleaned up on process exit. */\n  private static RUNNING_SERVERS: FlowServer[] = [];\n\n  /** Registry instance to be used for API calls. */\n  private registry: Registry;\n  /** Options for the flow server configured by the developer. */\n  private options: FlowServerOptions;\n  /** Port the server is actually running on. This may differ from `options.port` if the original was occupied. Null is server is not running. */\n  private port: number | null = null;\n  /** Express server instance. Null if server is not running. */\n  private server: Server | null = null;\n\n  constructor(registry: Registry, options: FlowServerOptions) {\n    this.registry = registry;\n    this.options = {\n      ...options,\n    };\n  }\n\n  /**\n   * Starts the server and adds it to the list of running servers to clean up on exit.\n   */\n  async start() {\n    const server = express();\n\n    server.use(bodyParser.json(this.options.jsonParserOptions));\n    server.use(cors(this.options.cors));\n\n    if (!!this.options.flows) {\n      logger.debug('Running flow server with flow paths:');\n      const pathPrefix = this.options.pathPrefix ?? '';\n      this.options.flows?.forEach((flow) => {\n        const flowPath = `/${pathPrefix}${flow.flow.name}`;\n        logger.debug(` - ${flowPath}`);\n        flow.flow.middleware?.forEach((middleware) =>\n          server.post(flowPath, middleware)\n        );\n        server.post(flowPath, (req, res) => flow.flow.expressHandler(req, res));\n      });\n    } else {\n      logger.warn('No flows registered in flow server.');\n    }\n    this.port =\n      this.options?.port ||\n      (process.env.PORT ? parseInt(process.env.PORT) : 0) ||\n      3400;\n    this.server = server.listen(this.port, () => {\n      logger.debug(`Flow server running on http://localhost:${this.port}`);\n      FlowServer.RUNNING_SERVERS.push(this);\n    });\n  }\n\n  /**\n   * Stops the server and removes it from the list of running servers to clean up on exit.\n   */\n  async stop(): Promise<void> {\n    if (!this.server) {\n      return;\n    }\n    return new Promise<void>((resolve, reject) => {\n      this.server!.close((err) => {\n        if (err) {\n          logger.error(\n            `Error shutting down flow server on port ${this.port}: ${err}`\n          );\n          reject(err);\n        }\n        const index = FlowServer.RUNNING_SERVERS.indexOf(this);\n        if (index > -1) {\n          FlowServer.RUNNING_SERVERS.splice(index, 1);\n        }\n        logger.debug(\n          `Flow server on port ${this.port} has successfully shut down.`\n        );\n        this.port = null;\n        this.server = null;\n        resolve();\n      });\n    });\n  }\n\n  /**\n   * Stops all running servers.\n   */\n  static async stopAll() {\n    return Promise.all(\n      FlowServer.RUNNING_SERVERS.map((server) => server.stop())\n    );\n  }\n}\n\n/**\n * Defines a non-streaming flow. This operates on the currently active registry.\n */\nexport function defineFlow<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  registry: Registry,\n  config: StreamingFlowConfig<I, O> | string,\n  fn: FlowFn<I, O, S>\n): CallableFlow<I, O, S> {\n  const resolvedConfig: FlowConfig<I, O> =\n    typeof config === 'string' ? { name: config } : config;\n\n  const flow = new Flow<I, O, S>(registry, resolvedConfig, fn);\n  registerFlowAction(registry, flow);\n  const callableFlow = async (\n    input: z.infer<I>,\n    opts: FlowCallOptions\n  ): Promise<z.infer<O>> => {\n    return flow.run(input, opts);\n  };\n  (callableFlow as CallableFlow<I, O, S>).flow = flow;\n  (callableFlow as CallableFlow<I, O, S>).stream = (\n    input: z.infer<I>,\n    opts: FlowCallOptions\n  ): StreamingResponse<O, S> => {\n    return flow.stream(input, opts);\n  };\n  return callableFlow as CallableFlow<I, O, S>;\n}\n\n/**\n * Defines a streaming flow. This operates on the currently active registry.\n */\nexport function defineStreamingFlow<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  registry: Registry,\n  config: StreamingFlowConfig<I, O, S>,\n  fn: FlowFn<I, O, S>\n): StreamableFlow<I, O, S> {\n  const flow = new Flow(registry, config, fn);\n  registerFlowAction(registry, flow);\n  const streamableFlow: StreamableFlow<I, O, S> = (input, opts) => {\n    return flow.stream(input, opts);\n  };\n  streamableFlow.flow = flow;\n  return streamableFlow;\n}\n\n/**\n * Registers a flow as an action in the registry.\n */\nfunction registerFlowAction<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  registry: Registry,\n  flow: Flow<I, O, S>\n): Action<typeof FlowActionInputSchema, O> {\n  return defineAction(\n    registry,\n    {\n      actionType: 'flow',\n      name: flow.name,\n      inputSchema: FlowActionInputSchema,\n      outputSchema: flow.outputSchema,\n      metadata: {\n        inputSchema: toJsonSchema({ schema: flow.inputSchema }),\n        outputSchema: toJsonSchema({ schema: flow.outputSchema }),\n        requiresAuth: !!flow.authPolicy,\n      },\n    },\n    async (envelope) => {\n      await flow.authPolicy?.(\n        envelope.auth,\n        envelope.start?.input as I | undefined\n      );\n      setCustomMetadataAttribute(flowMetadataPrefix('wrapperAction'), 'true');\n      const response = await flow.invoke(envelope.start?.input, {\n        streamingCallback: getStreamingCallback() as S extends z.ZodVoid\n          ? undefined\n          : StreamingCallback<z.infer<S>>,\n        auth: envelope.auth,\n        labels: envelope.start?.labels,\n      });\n      return response.result;\n    }\n  );\n}\n\nexport function run<T>(name: string, func: () => Promise<T>): Promise<T>;\nexport function run<T>(\n  name: string,\n  input: any,\n  func: (input?: any) => Promise<T>\n): Promise<T>;\n\n/**\n * A flow step that executes the provided function. Each run step is recorded separately in the trace.\n */\nexport function run<T>(\n  name: string,\n  funcOrInput: () => Promise<T>,\n  fn?: (input?: any) => Promise<T>\n): Promise<T> {\n  const func = arguments.length === 3 ? fn : funcOrInput;\n  const input = arguments.length === 3 ? funcOrInput : undefined;\n  if (!func) {\n    throw new Error('unable to resolve run function');\n  }\n  return runInNewSpan(\n    {\n      metadata: { name },\n      labels: {\n        [SPAN_TYPE_ATTR]: 'flowStep',\n      },\n    },\n    async (meta) => {\n      meta.input = input;\n      const output = arguments.length === 3 ? await func(input) : await func();\n      meta.output = JSON.stringify(output);\n      return output;\n    }\n  );\n}\n\n// TODO: Verify that this works.\nif (typeof module !== 'undefined' && 'hot' in module) {\n  (module as any).hot.accept();\n  (module as any).hot.dispose(async () => {\n    logger.debug('Cleaning up flow server(s) before module reload...');\n    await FlowServer.stopAll();\n  });\n}\n"],"mappings":"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","names":["express","cors","_a"]}