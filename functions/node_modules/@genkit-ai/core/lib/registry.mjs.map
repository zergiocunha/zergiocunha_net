{"version":3,"sources":["../src/registry.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as z from 'zod';\nimport { Action } from './action.js';\nimport { logger } from './logging.js';\nimport { PluginProvider } from './plugin.js';\nimport { JSONSchema } from './schema.js';\n\nexport type AsyncProvider<T> = () => Promise<T>;\n\n/**\n * Type of a runnable action.\n */\nexport type ActionType =\n  | 'custom'\n  | 'retriever'\n  | 'indexer'\n  | 'embedder'\n  | 'evaluator'\n  | 'flow'\n  | 'model'\n  | 'prompt'\n  | 'util'\n  | 'tool'\n  | 'reranker';\n\n/**\n * A schema is either a Zod schema or a JSON schema.\n */\nexport interface Schema {\n  schema?: z.ZodTypeAny;\n  jsonSchema?: JSONSchema;\n}\n\nfunction parsePluginName(registryKey: string) {\n  const tokens = registryKey.split('/');\n  if (tokens.length === 4) {\n    return tokens[2];\n  }\n  return undefined;\n}\n\ntype ActionsRecord = Record<string, Action<z.ZodTypeAny, z.ZodTypeAny>>;\n\n/**\n * The registry is used to store and lookup actions, trace stores, flow state stores, plugins, and schemas.\n */\nexport class Registry {\n  private actionsById: Record<string, Action<z.ZodTypeAny, z.ZodTypeAny>> = {};\n  private pluginsByName: Record<string, PluginProvider> = {};\n  private schemasByName: Record<string, Schema> = {};\n  private valueByTypeAndName: Record<string, Record<string, any>> = {};\n  private allPluginsInitialized = false;\n\n  constructor(public parent?: Registry) {}\n\n  /**\n   * Creates a new registry overlaid onto the provided registry.\n   * @param parent The parent registry.\n   * @returns The new overlaid registry.\n   */\n  static withParent(parent: Registry) {\n    return new Registry(parent);\n  }\n\n  /**\n   * Looks up an action in the registry.\n   * @param key The key of the action to lookup.\n   * @returns The action.\n   */\n  async lookupAction<\n    I extends z.ZodTypeAny,\n    O extends z.ZodTypeAny,\n    R extends Action<I, O>,\n  >(key: string): Promise<R> {\n    // If we don't see the key in the registry we try to initialize the plugin first.\n    const pluginName = parsePluginName(key);\n    if (!this.actionsById[key] && pluginName) {\n      await this.initializePlugin(pluginName);\n    }\n    return (this.actionsById[key] as R) || this.parent?.lookupAction(key);\n  }\n\n  /**\n   * Registers an action in the registry.\n   * @param type The type of the action to register.\n   * @param action The action to register.\n   */\n  registerAction<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(\n    type: ActionType,\n    action: Action<I, O>\n  ) {\n    const key = `/${type}/${action.__action.name}`;\n    logger.debug(`registering ${key}`);\n    if (this.actionsById.hasOwnProperty(key)) {\n      // TODO: Make this an error!\n      logger.warn(\n        `WARNING: ${key} already has an entry in the registry. Overwriting.`\n      );\n    }\n    this.actionsById[key] = action;\n  }\n\n  /**\n   * Returns all actions in the registry.\n   * @returns All actions in the registry.\n   */\n  async listActions(): Promise<ActionsRecord> {\n    await this.initializeAllPlugins();\n    return {\n      ...(await this.parent?.listActions()),\n      ...this.actionsById,\n    };\n  }\n\n  /**\n   * Initializes all plugins in the registry.\n   */\n  async initializeAllPlugins() {\n    if (this.allPluginsInitialized) {\n      return;\n    }\n    for (const pluginName of Object.keys(this.pluginsByName)) {\n      await this.initializePlugin(pluginName);\n    }\n    this.allPluginsInitialized = true;\n  }\n\n  /**\n   * Registers a plugin provider. This plugin must be initialized before it can be used by calling {@link initializePlugin} or {@link initializeAllPlugins}.\n   * @param name The name of the plugin to register.\n   * @param provider The plugin provider.\n   */\n  registerPluginProvider(name: string, provider: PluginProvider) {\n    if (this.pluginsByName[name]) {\n      throw new Error(`Plugin ${name} already registered`);\n    }\n    this.allPluginsInitialized = false;\n    let cached;\n    let isInitialized = false;\n    this.pluginsByName[name] = {\n      name: provider.name,\n      initializer: () => {\n        if (!isInitialized) {\n          cached = provider.initializer();\n          isInitialized = true;\n        }\n        return cached;\n      },\n    };\n  }\n\n  /**\n   * Looks up a plugin.\n   * @param name The name of the plugin to lookup.\n   * @returns The plugin provider.\n   */\n  lookupPlugin(name: string): PluginProvider | undefined {\n    return this.pluginsByName[name] || this.parent?.lookupPlugin(name);\n  }\n\n  /**\n   * Initializes a plugin already registered with {@link registerPluginProvider}.\n   * @param name The name of the plugin to initialize.\n   * @returns The plugin.\n   */\n  async initializePlugin(name: string) {\n    if (this.pluginsByName[name]) {\n      return await this.pluginsByName[name].initializer();\n    }\n  }\n\n  /**\n   * Registers a schema.\n   * @param name The name of the schema to register.\n   * @param data The schema to register (either a Zod schema or a JSON schema).\n   */\n  registerSchema(name: string, data: Schema) {\n    if (this.schemasByName[name]) {\n      throw new Error(`Schema ${name} already registered`);\n    }\n    this.schemasByName[name] = data;\n  }\n\n  registerValue(type: string, name: string, value: any) {\n    if (!this.valueByTypeAndName[type]) {\n      this.valueByTypeAndName[type] = {};\n    }\n    this.valueByTypeAndName[type][name] = value;\n  }\n\n  async lookupValue<T = unknown>(\n    type: string,\n    key: string\n  ): Promise<T | undefined> {\n    const pluginName = parsePluginName(key);\n    if (!this.valueByTypeAndName[type]?.[key] && pluginName) {\n      await this.initializePlugin(pluginName);\n    }\n    return (\n      (this.valueByTypeAndName[type]?.[key] as T) ||\n      this.parent?.lookupValue(type, key)\n    );\n  }\n\n  async listValues<T>(type: string): Promise<Record<string, T>> {\n    await this.initializeAllPlugins();\n    return {\n      ...((await this.parent?.listValues(type)) || {}),\n      ...(this.valueByTypeAndName[type] || {}),\n    } as Record<string, T>;\n  }\n\n  /**\n   * Looks up a schema.\n   * @param name The name of the schema to lookup.\n   * @returns The schema.\n   */\n  lookupSchema(name: string): Schema | undefined {\n    return this.schemasByName[name] || this.parent?.lookupSchema(name);\n  }\n}\n"],"mappings":";;;;AAkBA,SAAS,cAAc;AA8BvB,SAAS,gBAAgB,aAAqB;AAC5C,QAAM,SAAS,YAAY,MAAM,GAAG;AACpC,MAAI,OAAO,WAAW,GAAG;AACvB,WAAO,OAAO,CAAC;AAAA,EACjB;AACA,SAAO;AACT;AAOO,MAAM,SAAS;AAAA,EAOpB,YAAmB,QAAmB;AAAnB;AANnB,SAAQ,cAAkE,CAAC;AAC3E,SAAQ,gBAAgD,CAAC;AACzD,SAAQ,gBAAwC,CAAC;AACjD,SAAQ,qBAA0D,CAAC;AACnE,SAAQ,wBAAwB;AAAA,EAEO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOvC,OAAO,WAAW,QAAkB;AAClC,WAAO,IAAI,SAAS,MAAM;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOM,aAIJ,KAAyB;AAAA;AAxF7B;AA0FI,YAAM,aAAa,gBAAgB,GAAG;AACtC,UAAI,CAAC,KAAK,YAAY,GAAG,KAAK,YAAY;AACxC,cAAM,KAAK,iBAAiB,UAAU;AAAA,MACxC;AACA,aAAQ,KAAK,YAAY,GAAG,OAAW,UAAK,WAAL,mBAAa,aAAa;AAAA,IACnE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eACE,MACA,QACA;AACA,UAAM,MAAM,IAAI,IAAI,IAAI,OAAO,SAAS,IAAI;AAC5C,WAAO,MAAM,eAAe,GAAG,EAAE;AACjC,QAAI,KAAK,YAAY,eAAe,GAAG,GAAG;AAExC,aAAO;AAAA,QACL,YAAY,GAAG;AAAA,MACjB;AAAA,IACF;AACA,SAAK,YAAY,GAAG,IAAI;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMM,cAAsC;AAAA;AAzH9C;AA0HI,YAAM,KAAK,qBAAqB;AAChC,aAAO,kCACD,OAAM,UAAK,WAAL,mBAAa,gBACpB,KAAK;AAAA,IAEZ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKM,uBAAuB;AAAA;AAC3B,UAAI,KAAK,uBAAuB;AAC9B;AAAA,MACF;AACA,iBAAW,cAAc,OAAO,KAAK,KAAK,aAAa,GAAG;AACxD,cAAM,KAAK,iBAAiB,UAAU;AAAA,MACxC;AACA,WAAK,wBAAwB;AAAA,IAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,uBAAuB,MAAc,UAA0B;AAC7D,QAAI,KAAK,cAAc,IAAI,GAAG;AAC5B,YAAM,IAAI,MAAM,UAAU,IAAI,qBAAqB;AAAA,IACrD;AACA,SAAK,wBAAwB;AAC7B,QAAI;AACJ,QAAI,gBAAgB;AACpB,SAAK,cAAc,IAAI,IAAI;AAAA,MACzB,MAAM,SAAS;AAAA,MACf,aAAa,MAAM;AACjB,YAAI,CAAC,eAAe;AAClB,mBAAS,SAAS,YAAY;AAC9B,0BAAgB;AAAA,QAClB;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,MAA0C;AA3KzD;AA4KI,WAAO,KAAK,cAAc,IAAI,OAAK,UAAK,WAAL,mBAAa,aAAa;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOM,iBAAiB,MAAc;AAAA;AACnC,UAAI,KAAK,cAAc,IAAI,GAAG;AAC5B,eAAO,MAAM,KAAK,cAAc,IAAI,EAAE,YAAY;AAAA,MACpD;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAe,MAAc,MAAc;AACzC,QAAI,KAAK,cAAc,IAAI,GAAG;AAC5B,YAAM,IAAI,MAAM,UAAU,IAAI,qBAAqB;AAAA,IACrD;AACA,SAAK,cAAc,IAAI,IAAI;AAAA,EAC7B;AAAA,EAEA,cAAc,MAAc,MAAc,OAAY;AACpD,QAAI,CAAC,KAAK,mBAAmB,IAAI,GAAG;AAClC,WAAK,mBAAmB,IAAI,IAAI,CAAC;AAAA,IACnC;AACA,SAAK,mBAAmB,IAAI,EAAE,IAAI,IAAI;AAAA,EACxC;AAAA,EAEM,YACJ,MACA,KACwB;AAAA;AAhN5B;AAiNI,YAAM,aAAa,gBAAgB,GAAG;AACtC,UAAI,GAAC,UAAK,mBAAmB,IAAI,MAA5B,mBAAgC,SAAQ,YAAY;AACvD,cAAM,KAAK,iBAAiB,UAAU;AAAA,MACxC;AACA,eACG,UAAK,mBAAmB,IAAI,MAA5B,mBAAgC,WACjC,UAAK,WAAL,mBAAa,YAAY,MAAM;AAAA,IAEnC;AAAA;AAAA,EAEM,WAAc,MAA0C;AAAA;AA3NhE;AA4NI,YAAM,KAAK,qBAAqB;AAChC,aAAO,mCACA,OAAM,UAAK,WAAL,mBAAa,WAAW,UAAU,CAAC,IAC1C,KAAK,mBAAmB,IAAI,KAAK,CAAC;AAAA,IAE1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,MAAkC;AAxOjD;AAyOI,WAAO,KAAK,cAAc,IAAI,OAAK,UAAK,WAAL,mBAAa,aAAa;AAAA,EAC/D;AACF;","names":[]}