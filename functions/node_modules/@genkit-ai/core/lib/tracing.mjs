import {
  __async
} from "./chunk-VQ2XICTI.mjs";
import { NodeSDK } from "@opentelemetry/sdk-node";
import {
  BatchSpanProcessor,
  SimpleSpanProcessor
} from "@opentelemetry/sdk-trace-base";
import { logger } from "./logging.js";
import { TraceServerExporter } from "./tracing/exporter.js";
import { isDevEnv } from "./utils.js";
export * from "./tracing/exporter.js";
export * from "./tracing/instrumentation.js";
export * from "./tracing/processor.js";
export * from "./tracing/types.js";
let telemetrySDK = null;
let nodeOtelConfig = null;
const instrumentationKey = "__GENKIT_TELEMETRY_INSTRUMENTED";
function ensureBasicTelemetryInstrumentation() {
  return __async(this, null, function* () {
    if (global[instrumentationKey]) {
      return yield global[instrumentationKey];
    }
    yield enableTelemetry({});
  });
}
function enableTelemetry(telemetryConfig) {
  return __async(this, null, function* () {
    global[instrumentationKey] = telemetryConfig instanceof Promise ? telemetryConfig : Promise.resolve();
    telemetryConfig = telemetryConfig instanceof Promise ? yield telemetryConfig : telemetryConfig;
    nodeOtelConfig = telemetryConfig || {};
    const processors = [createTelemetryServerProcessor()];
    if (nodeOtelConfig.traceExporter) {
      throw new Error("Please specify spanProcessors instead.");
    }
    if (nodeOtelConfig.spanProcessors) {
      processors.push(...nodeOtelConfig.spanProcessors);
    }
    if (nodeOtelConfig.spanProcessor) {
      processors.push(nodeOtelConfig.spanProcessor);
      delete nodeOtelConfig.spanProcessor;
    }
    nodeOtelConfig.spanProcessors = processors;
    telemetrySDK = new NodeSDK(nodeOtelConfig);
    telemetrySDK.start();
    process.on("SIGTERM", () => __async(this, null, function* () {
      return yield cleanUpTracing();
    }));
  });
}
function cleanUpTracing() {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      if (telemetrySDK) {
        const metricFlush = maybeFlushMetrics();
        return metricFlush.then(() => {
          return telemetrySDK.shutdown().then(() => {
            logger.debug("OpenTelemetry SDK shut down.");
            telemetrySDK = null;
            resolve();
          });
        });
      } else {
        resolve();
      }
    });
  });
}
function createTelemetryServerProcessor() {
  const exporter = new TraceServerExporter();
  return isDevEnv() ? new SimpleSpanProcessor(exporter) : new BatchSpanProcessor(exporter);
}
function maybeFlushMetrics() {
  if (nodeOtelConfig == null ? void 0 : nodeOtelConfig.metricReader) {
    return nodeOtelConfig.metricReader.forceFlush();
  }
  return Promise.resolve();
}
function flushTracing() {
  return __async(this, null, function* () {
    if (nodeOtelConfig == null ? void 0 : nodeOtelConfig.spanProcessors) {
      yield Promise.all(nodeOtelConfig.spanProcessors.map((p) => p.forceFlush()));
    }
  });
}
export {
  cleanUpTracing,
  enableTelemetry,
  ensureBasicTelemetryInstrumentation,
  flushTracing
};
//# sourceMappingURL=tracing.mjs.map