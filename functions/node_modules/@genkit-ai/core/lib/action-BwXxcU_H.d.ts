import { JSONSchema7 } from 'json-schema';
import * as z from 'zod';
import { z as z$1 } from 'zod';
import './statusTypes.js';
import { JSONSchemaType, ErrorObject } from 'ajv';
import { GenkitError } from './error.js';

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

interface Provider<T> {
    id: string;
    value: T;
}
interface PluginProvider {
    name: string;
    initializer: () => InitializedPlugin | void | Promise<InitializedPlugin | void>;
}
interface InitializedPlugin {
    models?: Action<z$1.ZodTypeAny, z$1.ZodTypeAny>[];
    retrievers?: Action<z$1.ZodTypeAny, z$1.ZodTypeAny>[];
    embedders?: Action<z$1.ZodTypeAny, z$1.ZodTypeAny>[];
    indexers?: Action<z$1.ZodTypeAny, z$1.ZodTypeAny>[];
    evaluators?: Action<z$1.ZodTypeAny, z$1.ZodTypeAny>[];
    /** @deprecated */
    flowStateStore?: Provider<any> | Provider<any>[];
    /** @deprecated */
    traceStore?: Provider<any> | Provider<any>[];
    /** @deprecated */
    telemetry?: any;
}
type PluginInit = (...args: any[]) => InitializedPlugin | void | Promise<InitializedPlugin | void>;
type Plugin<T extends any[]> = (...args: T) => PluginProvider;
/**
 * Defines a Genkit plugin.
 */
declare function genkitPlugin<T extends PluginInit>(pluginName: string, initFn: T): Plugin<Parameters<T>>;

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

type JSONSchema = JSONSchemaType<any> | any;
interface ProvidedSchema {
    jsonSchema?: JSONSchema;
    schema?: z$1.ZodTypeAny;
}
declare class ValidationError extends GenkitError {
    constructor({ data, errors, schema, }: {
        data: any;
        errors: ValidationErrorDetail[];
        schema: JSONSchema;
    });
}
/**
 * Convertes a Zod schema into a JSON schema, utilizing an in-memory cache for known objects.
 * @param options Provide a json schema and/or zod schema. JSON schema has priority.
 * @returns A JSON schema.
 */
declare function toJsonSchema({ jsonSchema, schema, }: ProvidedSchema): JSONSchema | undefined;
interface ValidationErrorDetail {
    path: string;
    message: string;
}
type ValidationResponse = {
    valid: true;
    errors: never;
} | {
    valid: false;
    errors: ErrorObject[];
};
declare function validateSchema(data: unknown, options: ProvidedSchema): {
    valid: boolean;
    errors?: any[];
    schema: JSONSchema;
};
declare function parseSchema<T = unknown>(data: unknown, options: ProvidedSchema): T;
declare function defineSchema<T extends z$1.ZodTypeAny>(registry: Registry, name: string, schema: T): T;
declare function defineJsonSchema(registry: Registry, name: string, jsonSchema: JSONSchema): any;

type AsyncProvider<T> = () => Promise<T>;
/**
 * Type of a runnable action.
 */
type ActionType = 'custom' | 'retriever' | 'indexer' | 'embedder' | 'evaluator' | 'flow' | 'model' | 'prompt' | 'util' | 'tool' | 'reranker';
/**
 * A schema is either a Zod schema or a JSON schema.
 */
interface Schema {
    schema?: z.ZodTypeAny;
    jsonSchema?: JSONSchema;
}
type ActionsRecord = Record<string, Action<z.ZodTypeAny, z.ZodTypeAny>>;
/**
 * The registry is used to store and lookup actions, trace stores, flow state stores, plugins, and schemas.
 */
declare class Registry {
    parent?: Registry | undefined;
    private actionsById;
    private pluginsByName;
    private schemasByName;
    private valueByTypeAndName;
    private allPluginsInitialized;
    constructor(parent?: Registry | undefined);
    /**
     * Creates a new registry overlaid onto the provided registry.
     * @param parent The parent registry.
     * @returns The new overlaid registry.
     */
    static withParent(parent: Registry): Registry;
    /**
     * Looks up an action in the registry.
     * @param key The key of the action to lookup.
     * @returns The action.
     */
    lookupAction<I extends z.ZodTypeAny, O extends z.ZodTypeAny, R extends Action<I, O>>(key: string): Promise<R>;
    /**
     * Registers an action in the registry.
     * @param type The type of the action to register.
     * @param action The action to register.
     */
    registerAction<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(type: ActionType, action: Action<I, O>): void;
    /**
     * Returns all actions in the registry.
     * @returns All actions in the registry.
     */
    listActions(): Promise<ActionsRecord>;
    /**
     * Initializes all plugins in the registry.
     */
    initializeAllPlugins(): Promise<void>;
    /**
     * Registers a plugin provider. This plugin must be initialized before it can be used by calling {@link initializePlugin} or {@link initializeAllPlugins}.
     * @param name The name of the plugin to register.
     * @param provider The plugin provider.
     */
    registerPluginProvider(name: string, provider: PluginProvider): void;
    /**
     * Looks up a plugin.
     * @param name The name of the plugin to lookup.
     * @returns The plugin provider.
     */
    lookupPlugin(name: string): PluginProvider | undefined;
    /**
     * Initializes a plugin already registered with {@link registerPluginProvider}.
     * @param name The name of the plugin to initialize.
     * @returns The plugin.
     */
    initializePlugin(name: string): Promise<void | InitializedPlugin>;
    /**
     * Registers a schema.
     * @param name The name of the schema to register.
     * @param data The schema to register (either a Zod schema or a JSON schema).
     */
    registerSchema(name: string, data: Schema): void;
    registerValue(type: string, name: string, value: any): void;
    lookupValue<T = unknown>(type: string, key: string): Promise<T | undefined>;
    listValues<T>(type: string): Promise<Record<string, T>>;
    /**
     * Looks up a schema.
     * @param name The name of the schema to lookup.
     * @returns The schema.
     */
    lookupSchema(name: string): Schema | undefined;
}

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Action metadata.
 */
interface ActionMetadata<I extends z.ZodTypeAny, O extends z.ZodTypeAny, S extends z.ZodTypeAny> {
    actionType?: ActionType;
    name: string;
    description?: string;
    inputSchema?: I;
    inputJsonSchema?: JSONSchema7;
    outputSchema?: O;
    outputJsonSchema?: JSONSchema7;
    streamSchema?: S;
    metadata?: Record<string, any>;
}
/**
 * Results of an action run. Includes telemetry.
 */
interface ActionResult<O> {
    result: O;
    telemetry: {
        traceId: string;
        spanId: string;
    };
}
/**
 * Options (side channel) data to pass to the model.
 */
interface ActionRunOptions<S> {
    /**
     * Streaming callback (optional).
     */
    onChunk?: StreamingCallback<S>;
    /**
     * Additional runtime context data (ex. auth context data).
     */
    context?: any;
}
/**
 * Options (side channel) data to pass to the model.
 */
interface ActionFnArg<S> {
    /**
     * Streaming callback (optional).
     */
    sendChunk: StreamingCallback<S>;
    /**
     * Additional runtime context data (ex. auth context data).
     */
    context?: any;
}
/**
 * Self-describing, validating, observable, locally and remotely callable function.
 */
type Action<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny> = ((input: z.infer<I>, options?: ActionRunOptions<S>) => Promise<z.infer<O>>) & {
    __action: ActionMetadata<I, O, S>;
    run(input: z.infer<I>, options?: ActionRunOptions<z.infer<S>>): Promise<ActionResult<z.infer<O>>>;
};
/**
 * Action factory params.
 */
type ActionParams<I extends z.ZodTypeAny, O extends z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny> = {
    name: string | {
        pluginId: string;
        actionId: string;
    };
    description?: string;
    inputSchema?: I;
    inputJsonSchema?: JSONSchema7;
    outputSchema?: O;
    outputJsonSchema?: JSONSchema7;
    metadata?: Record<string, any>;
    use?: Middleware<z.infer<I>, z.infer<O>, z.infer<S>>[];
    streamingSchema?: S;
};
type SimpleMiddleware<I = any, O = any> = (req: I, next: (req?: I) => Promise<O>) => Promise<O>;
type MiddlewareWithOptions<I = any, O = any, S = any> = (req: I, options: ActionRunOptions<S> | undefined, next: (req?: I, options?: ActionRunOptions<S>) => Promise<O>) => Promise<O>;
/**
 * Middleware function for actions.
 */
type Middleware<I = any, O = any, S = any> = SimpleMiddleware<I, O> | MiddlewareWithOptions<I, O, S>;
/**
 * Creates an action with provided middleware.
 */
declare function actionWithMiddleware<I extends z.ZodTypeAny, O extends z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(action: Action<I, O, S>, middleware: Middleware<z.infer<I>, z.infer<O>, z.infer<S>>[]): Action<I, O, S>;
/**
 * Creates an action with the provided config.
 */
declare function action<I extends z.ZodTypeAny, O extends z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(config: ActionParams<I, O, S>, fn: (input: z.infer<I>, options: ActionFnArg<z.infer<S>>) => Promise<z.infer<O>>): Action<I, O, z.infer<S>>;
/**
 * Defines an action with the given config and registers it in the registry.
 */
declare function defineAction<I extends z.ZodTypeAny, O extends z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(registry: Registry, config: ActionParams<I, O, S> & {
    actionType: ActionType;
}, fn: (input: z.infer<I>, options: ActionFnArg<z.infer<S>>) => Promise<z.infer<O>>): Action<I, O>;
type StreamingCallback<T> = (chunk: T) => void;
/**
 * Executes provided function with streaming callback in async local storage which can be retrieved
 * using {@link getStreamingCallback}.
 */
declare function runWithStreamingCallback<S, O>(streamingCallback: StreamingCallback<S> | undefined, fn: () => O): O;
/**
 * Retrieves the {@link StreamingCallback} previously set by {@link runWithStreamingCallback}
 */
declare function getStreamingCallback<S>(): StreamingCallback<S> | undefined;
/**
 * Checks whether the caller is currently in the runtime context of an action.
 */
declare function isInRuntimeContext(): boolean;
/**
 * Execute the provided function in the action runtime context.
 */
declare function runInActionRuntimeContext<R>(fn: () => R): R;

export { type ActionMetadata as A, type Schema as B, type InitializedPlugin as I, type JSONSchema as J, type MiddlewareWithOptions as M, type Provider as P, Registry as R, type SimpleMiddleware as S, ValidationError as V, defineSchema as a, type ActionResult as b, type ActionRunOptions as c, defineJsonSchema as d, type ActionFnArg as e, type Action as f, type Middleware as g, actionWithMiddleware as h, action as i, defineAction as j, type StreamingCallback as k, getStreamingCallback as l, isInRuntimeContext as m, runInActionRuntimeContext as n, type PluginProvider as o, type Plugin as p, genkitPlugin as q, runWithStreamingCallback as r, type ProvidedSchema as s, toJsonSchema as t, type ValidationErrorDetail as u, type ValidationResponse as v, validateSchema as w, parseSchema as x, type AsyncProvider as y, type ActionType as z };
