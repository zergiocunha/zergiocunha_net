import * as bodyParser from 'body-parser';
import { CorsOptions } from 'cors';
import express from 'express';
import { z } from 'zod';
import { k as StreamingCallback, R as Registry } from './action-BwXxcU_H.js';
import 'json-schema';
import './statusTypes.js';
import 'ajv';
import './error.js';

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Flow Auth policy. Consumes the authorization context of the flow and
 * performs checks before the flow runs. If this throws, the flow will not
 * be executed.
 */
interface FlowAuthPolicy<I extends z.ZodTypeAny = z.ZodTypeAny> {
    (auth: any | undefined, input: z.infer<I>): void | Promise<void>;
}
/**
 * For express-based flows, req.auth should contain the value to bepassed into
 * the flow context.
 */
interface __RequestWithAuth extends express.Request {
    auth?: unknown;
}
/**
 * Configuration for a flow.
 */
interface FlowConfig<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny> {
    /** Name of the flow. */
    name: string;
    /** Schema of the input to the flow. */
    inputSchema?: I;
    /** Schema of the output from the flow. */
    outputSchema?: O;
    /** Auth policy. */
    authPolicy?: FlowAuthPolicy<I>;
    /** Middleware for HTTP requests. Not called for direct invocations. */
    middleware?: express.RequestHandler[];
}
/**
 * Configuration for a streaming flow.
 */
interface StreamingFlowConfig<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny> extends FlowConfig<I, O> {
    /** Schema of the streaming chunks from the flow. */
    streamSchema?: S;
}
interface FlowCallOptions {
    /** @deprecated use {@link context} instead. */
    withLocalAuthContext?: unknown;
    context?: unknown;
}
/**
 * Non-streaming flow that can be called directly like a function.
 */
interface CallableFlow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny> {
    (input?: z.infer<I>, opts?: FlowCallOptions): Promise<z.infer<O>>;
    stream(input?: z.infer<I>, opts?: FlowCallOptions): StreamingResponse<O, S>;
    flow: Flow<I, O, z.ZodVoid>;
}
/**
 * Streaming flow that can be called directly like a function.
 * @deprecated use {@link CallableFlow}
 */
interface StreamableFlow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny> {
    (input?: z.infer<I>, opts?: FlowCallOptions): StreamingResponse<O, S>;
    flow: Flow<I, O, S>;
}
/**
 * Response from a streaming flow.
 */
interface StreamingResponse<O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny> {
    /** Iterator over the streaming chunks. */
    stream: AsyncGenerator<z.infer<S>>;
    /** Final output of the flow. */
    output: Promise<z.infer<O>>;
}
/**
 * Function to be executed in the flow.
 */
type FlowFn<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny> = (
/** Input to the flow. */
input: z.infer<I>, 
/** Callback for streaming functions only. */
streamingCallback: StreamingCallback<z.infer<S>>) => Promise<z.infer<O>> | z.infer<O>;
/**
 * Represents the result of a flow execution.
 */
interface FlowResult<O> {
    /** The result of the flow execution. */
    result: O;
    /** The trace ID associated with the flow execution. */
    traceId: string;
    /** The root span ID of the associated trace. */
    spanId: string;
}
declare class Flow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny> {
    private registry;
    readonly name: string;
    readonly inputSchema?: I;
    readonly outputSchema?: O;
    readonly streamSchema?: S;
    readonly authPolicy?: FlowAuthPolicy<I>;
    readonly middleware?: express.RequestHandler[];
    readonly flowFn: FlowFn<I, O, S>;
    constructor(registry: Registry, config: FlowConfig<I, O> | StreamingFlowConfig<I, O, S>, flowFn: FlowFn<I, O, S>);
    /**
     * Executes the flow with the input directly.
     */
    invoke(input: unknown, opts: {
        streamingCallback?: StreamingCallback<z.infer<S>>;
        labels?: Record<string, string>;
        auth?: unknown;
    }): Promise<FlowResult<z.infer<O>>>;
    /**
     * Runs the flow. This is used when calling a flow from another flow.
     */
    run(payload?: z.infer<I>, opts?: FlowCallOptions): Promise<z.infer<O>>;
    /**
     * Runs the flow and streams results. This is used when calling a flow from another flow.
     */
    stream(payload?: z.infer<I>, opts?: FlowCallOptions): StreamingResponse<O, S>;
    expressHandler(request: __RequestWithAuth, response: express.Response): Promise<void>;
}
/**
 * Options to configure the flow server.
 */
interface FlowServerOptions {
    /** List of flows to expose via the flow server. */
    flows: (CallableFlow<any, any> | StreamableFlow<any, any>)[];
    /** Port to run the server on. Defaults to env.PORT or 3400. */
    port?: number;
    /** CORS options for the server. */
    cors?: CorsOptions;
    /** HTTP method path prefix for the exposed flows. */
    pathPrefix?: string;
    /** JSON body parser options. */
    jsonParserOptions?: bodyParser.OptionsJson;
}
/**
 * Flow server exposes registered flows as HTTP endpoints.
 *
 * This is for use in production environments.
 */
declare class FlowServer {
    /** List of all running servers needed to be cleaned up on process exit. */
    private static RUNNING_SERVERS;
    /** Registry instance to be used for API calls. */
    private registry;
    /** Options for the flow server configured by the developer. */
    private options;
    /** Port the server is actually running on. This may differ from `options.port` if the original was occupied. Null is server is not running. */
    private port;
    /** Express server instance. Null if server is not running. */
    private server;
    constructor(registry: Registry, options: FlowServerOptions);
    /**
     * Starts the server and adds it to the list of running servers to clean up on exit.
     */
    start(): Promise<void>;
    /**
     * Stops the server and removes it from the list of running servers to clean up on exit.
     */
    stop(): Promise<void>;
    /**
     * Stops all running servers.
     */
    static stopAll(): Promise<void[]>;
}
/**
 * Defines a non-streaming flow. This operates on the currently active registry.
 */
declare function defineFlow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(registry: Registry, config: StreamingFlowConfig<I, O> | string, fn: FlowFn<I, O, S>): CallableFlow<I, O, S>;
/**
 * Defines a streaming flow. This operates on the currently active registry.
 */
declare function defineStreamingFlow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(registry: Registry, config: StreamingFlowConfig<I, O, S>, fn: FlowFn<I, O, S>): StreamableFlow<I, O, S>;
declare function run<T>(name: string, func: () => Promise<T>): Promise<T>;
declare function run<T>(name: string, input: any, func: (input?: any) => Promise<T>): Promise<T>;

export { type CallableFlow, Flow, type FlowAuthPolicy, type FlowCallOptions, type FlowConfig, type FlowFn, FlowServer, type FlowServerOptions, type StreamableFlow, type StreamingFlowConfig, type __RequestWithAuth, defineFlow, defineStreamingFlow, run };
