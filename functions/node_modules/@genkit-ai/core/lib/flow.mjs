import {
  __async,
  __asyncGenerator,
  __await,
  __spreadValues
} from "./chunk-VQ2XICTI.mjs";
import { SpanStatusCode } from "@opentelemetry/api";
import * as bodyParser from "body-parser";
import cors from "cors";
import express from "express";
import {
  defineAction,
  getStreamingCallback
} from "./action.js";
import { runWithAuthContext } from "./auth.js";
import { getErrorMessage, getErrorStack } from "./error.js";
import { FlowActionInputSchema } from "./flowTypes.js";
import { logger } from "./logging.js";
import { toJsonSchema } from "./schema.js";
import {
  newTrace,
  runInNewSpan,
  setCustomMetadataAttribute,
  setCustomMetadataAttributes,
  SPAN_TYPE_ATTR
} from "./tracing.js";
import { flowMetadataPrefix } from "./utils.js";
const streamDelimiter = "\n\n";
class Flow {
  constructor(registry, config, flowFn) {
    this.registry = registry;
    this.name = config.name;
    this.inputSchema = config.inputSchema;
    this.outputSchema = config.outputSchema;
    this.streamSchema = "streamSchema" in config ? config.streamSchema : void 0;
    this.authPolicy = config.authPolicy;
    this.middleware = config.middleware;
    this.flowFn = flowFn;
  }
  /**
   * Executes the flow with the input directly.
   */
  invoke(input, opts) {
    return __async(this, null, function* () {
      yield this.registry.initializeAllPlugins();
      return yield runWithAuthContext(
        opts.auth,
        () => newTrace(
          {
            name: this.name,
            labels: {
              [SPAN_TYPE_ATTR]: "flow"
            }
          },
          (metadata, rootSpan) => __async(this, null, function* () {
            var _a;
            if (opts.labels) {
              const labels = opts.labels;
              Object.keys(opts.labels).forEach((label) => {
                setCustomMetadataAttribute(
                  flowMetadataPrefix(`label:${label}`),
                  labels[label]
                );
              });
            }
            setCustomMetadataAttributes({
              [flowMetadataPrefix("name")]: this.name
            });
            try {
              metadata.input = input;
              const output = yield this.flowFn(
                input,
                (_a = opts.streamingCallback) != null ? _a : () => {
                }
              );
              metadata.output = JSON.stringify(output);
              setCustomMetadataAttribute(flowMetadataPrefix("state"), "done");
              return {
                result: output,
                traceId: rootSpan.spanContext().traceId,
                spanId: rootSpan.spanContext().spanId
              };
            } catch (e) {
              metadata.state = "error";
              rootSpan.setStatus({
                code: SpanStatusCode.ERROR,
                message: getErrorMessage(e)
              });
              if (e instanceof Error) {
                rootSpan.recordException(e);
              }
              setCustomMetadataAttribute(flowMetadataPrefix("state"), "error");
              throw e;
            }
          })
        )
      );
    });
  }
  /**
   * Runs the flow. This is used when calling a flow from another flow.
   */
  run(payload, opts) {
    return __async(this, null, function* () {
      var _a;
      const input = this.inputSchema ? this.inputSchema.parse(payload) : payload;
      yield (_a = this.authPolicy) == null ? void 0 : _a.call(this, opts == null ? void 0 : opts.withLocalAuthContext, payload);
      if (this.middleware) {
        logger.warn(
          `Flow (${this.name}) middleware won't run when invoked with runFlow.`
        );
      }
      const result = yield this.invoke(input, {
        auth: (opts == null ? void 0 : opts.context) || (opts == null ? void 0 : opts.withLocalAuthContext)
      });
      return result.result;
    });
  }
  /**
   * Runs the flow and streams results. This is used when calling a flow from another flow.
   */
  stream(payload, opts) {
    var _a, _b;
    let chunkStreamController;
    const chunkStream = new ReadableStream({
      start(controller) {
        chunkStreamController = controller;
      },
      pull() {
      },
      cancel() {
      }
    });
    const authPromise = (_b = (_a = this.authPolicy) == null ? void 0 : _a.call(this, (opts == null ? void 0 : opts.context) || (opts == null ? void 0 : opts.withLocalAuthContext), payload)) != null ? _b : Promise.resolve();
    const invocationPromise = authPromise.then(
      () => this.invoke(
        this.inputSchema ? this.inputSchema.parse(payload) : payload,
        {
          streamingCallback: (chunk) => {
            chunkStreamController.enqueue(chunk);
          },
          auth: (opts == null ? void 0 : opts.context) || (opts == null ? void 0 : opts.withLocalAuthContext)
        }
      ).then((s) => s.result)
    ).finally(() => {
      chunkStreamController.close();
    });
    return {
      output: invocationPromise,
      stream: function() {
        return __asyncGenerator(this, null, function* () {
          const reader = chunkStream.getReader();
          while (true) {
            const chunk = yield new __await(reader.read());
            if (chunk.value) {
              yield chunk.value;
            }
            if (chunk.done) {
              break;
            }
          }
          return yield new __await(invocationPromise);
        });
      }()
    };
  }
  expressHandler(request, response) {
    return __async(this, null, function* () {
      var _a;
      const { stream } = request.query;
      const auth = request.auth;
      let input = request.body.data;
      try {
        yield (_a = this.authPolicy) == null ? void 0 : _a.call(this, auth, input);
      } catch (e) {
        const respBody = {
          error: {
            status: "PERMISSION_DENIED",
            message: e.message || "Permission denied to resource"
          }
        };
        response.status(403).send(respBody).end();
        return;
      }
      if (request.get("Accept") === "text/event-stream" || stream === "true") {
        response.writeHead(200, {
          "Content-Type": "text/plain",
          "Transfer-Encoding": "chunked"
        });
        try {
          const result = yield this.invoke(input, {
            streamingCallback: (chunk) => {
              response.write(
                "data: " + JSON.stringify({ message: chunk }) + streamDelimiter
              );
            },
            auth
          });
          response.write(
            "data: " + JSON.stringify({ result: result.result }) + streamDelimiter
          );
          response.end();
        } catch (e) {
          console.log(e);
          response.write(
            "data: " + JSON.stringify({
              error: {
                status: "INTERNAL",
                message: getErrorMessage(e),
                details: getErrorStack(e)
              }
            }) + streamDelimiter
          );
          response.end();
        }
      } else {
        try {
          const result = yield this.invoke(input, { auth });
          response.setHeader("x-genkit-trace-id", result.traceId);
          response.setHeader("x-genkit-span-id", result.spanId);
          response.status(200).send({
            result: result.result
          }).end();
        } catch (e) {
          response.status(500).send({
            error: {
              status: "INTERNAL",
              message: getErrorMessage(e),
              details: getErrorStack(e)
            }
          }).end();
        }
      }
    });
  }
}
const _FlowServer = class _FlowServer {
  constructor(registry, options) {
    /** Port the server is actually running on. This may differ from `options.port` if the original was occupied. Null is server is not running. */
    this.port = null;
    /** Express server instance. Null if server is not running. */
    this.server = null;
    this.registry = registry;
    this.options = __spreadValues({}, options);
  }
  /**
   * Starts the server and adds it to the list of running servers to clean up on exit.
   */
  start() {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const server = express();
      server.use(bodyParser.json(this.options.jsonParserOptions));
      server.use(cors(this.options.cors));
      if (!!this.options.flows) {
        logger.debug("Running flow server with flow paths:");
        const pathPrefix = (_a = this.options.pathPrefix) != null ? _a : "";
        (_b = this.options.flows) == null ? void 0 : _b.forEach((flow) => {
          var _a2;
          const flowPath = `/${pathPrefix}${flow.flow.name}`;
          logger.debug(` - ${flowPath}`);
          (_a2 = flow.flow.middleware) == null ? void 0 : _a2.forEach(
            (middleware) => server.post(flowPath, middleware)
          );
          server.post(flowPath, (req, res) => flow.flow.expressHandler(req, res));
        });
      } else {
        logger.warn("No flows registered in flow server.");
      }
      this.port = ((_c = this.options) == null ? void 0 : _c.port) || (process.env.PORT ? parseInt(process.env.PORT) : 0) || 3400;
      this.server = server.listen(this.port, () => {
        logger.debug(`Flow server running on http://localhost:${this.port}`);
        _FlowServer.RUNNING_SERVERS.push(this);
      });
    });
  }
  /**
   * Stops the server and removes it from the list of running servers to clean up on exit.
   */
  stop() {
    return __async(this, null, function* () {
      if (!this.server) {
        return;
      }
      return new Promise((resolve, reject) => {
        this.server.close((err) => {
          if (err) {
            logger.error(
              `Error shutting down flow server on port ${this.port}: ${err}`
            );
            reject(err);
          }
          const index = _FlowServer.RUNNING_SERVERS.indexOf(this);
          if (index > -1) {
            _FlowServer.RUNNING_SERVERS.splice(index, 1);
          }
          logger.debug(
            `Flow server on port ${this.port} has successfully shut down.`
          );
          this.port = null;
          this.server = null;
          resolve();
        });
      });
    });
  }
  /**
   * Stops all running servers.
   */
  static stopAll() {
    return __async(this, null, function* () {
      return Promise.all(
        _FlowServer.RUNNING_SERVERS.map((server) => server.stop())
      );
    });
  }
};
/** List of all running servers needed to be cleaned up on process exit. */
_FlowServer.RUNNING_SERVERS = [];
let FlowServer = _FlowServer;
function defineFlow(registry, config, fn) {
  const resolvedConfig = typeof config === "string" ? { name: config } : config;
  const flow = new Flow(registry, resolvedConfig, fn);
  registerFlowAction(registry, flow);
  const callableFlow = (input, opts) => __async(this, null, function* () {
    return flow.run(input, opts);
  });
  callableFlow.flow = flow;
  callableFlow.stream = (input, opts) => {
    return flow.stream(input, opts);
  };
  return callableFlow;
}
function defineStreamingFlow(registry, config, fn) {
  const flow = new Flow(registry, config, fn);
  registerFlowAction(registry, flow);
  const streamableFlow = (input, opts) => {
    return flow.stream(input, opts);
  };
  streamableFlow.flow = flow;
  return streamableFlow;
}
function registerFlowAction(registry, flow) {
  return defineAction(
    registry,
    {
      actionType: "flow",
      name: flow.name,
      inputSchema: FlowActionInputSchema,
      outputSchema: flow.outputSchema,
      metadata: {
        inputSchema: toJsonSchema({ schema: flow.inputSchema }),
        outputSchema: toJsonSchema({ schema: flow.outputSchema }),
        requiresAuth: !!flow.authPolicy
      }
    },
    (envelope) => __async(this, null, function* () {
      var _a, _b, _c, _d;
      yield (_b = flow.authPolicy) == null ? void 0 : _b.call(
        flow,
        envelope.auth,
        (_a = envelope.start) == null ? void 0 : _a.input
      );
      setCustomMetadataAttribute(flowMetadataPrefix("wrapperAction"), "true");
      const response = yield flow.invoke((_c = envelope.start) == null ? void 0 : _c.input, {
        streamingCallback: getStreamingCallback(),
        auth: envelope.auth,
        labels: (_d = envelope.start) == null ? void 0 : _d.labels
      });
      return response.result;
    })
  );
}
function run(name, funcOrInput, fn) {
  var _arguments = arguments;
  const func = arguments.length === 3 ? fn : funcOrInput;
  const input = arguments.length === 3 ? funcOrInput : void 0;
  if (!func) {
    throw new Error("unable to resolve run function");
  }
  return runInNewSpan(
    {
      metadata: { name },
      labels: {
        [SPAN_TYPE_ATTR]: "flowStep"
      }
    },
    (meta) => __async(this, null, function* () {
      meta.input = input;
      const output = _arguments.length === 3 ? yield func(input) : yield func();
      meta.output = JSON.stringify(output);
      return output;
    })
  );
}
if (typeof module !== "undefined" && "hot" in module) {
  module.hot.accept();
  module.hot.dispose(() => __async(void 0, null, function* () {
    logger.debug("Cleaning up flow server(s) before module reload...");
    yield FlowServer.stopAll();
  }));
}
export {
  Flow,
  FlowServer,
  defineFlow,
  defineStreamingFlow,
  run
};
//# sourceMappingURL=flow.mjs.map